C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BLE
OBJECT MODULE PLACED IN ble.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE ble.c LARGE OMF2 BROWSE DEBUG TABS(2)

line level    source

   1          #include "ble.h"
   2          #include "string.h"
   3          #include "usart.h"
   4          #include "task.h"
   5          #include "config.h"
   6          #include "stdio.h"
   7          #include "share.h"
   8          #include "sync.h"
   9          #include "utils.h"
  10          #include "key.h"
  11          #include "debug.h"
  12          #define error_code 0x00
  13          
  14          #define ble_send_command(x)   PrintString1(x)
  15          #define ble_recieve_data(x)   GetString1(x)
  16          #define ble_send_data(x)      PrintString2(x)
  17          
  18          static code unsigned char const BLE_IND_LINKED[] = "Connected\r\n";
  19          static code unsigned char const BLE_IND_ADVERTISING[] = "Advertising\r\n";
  20          static code unsigned char const BLE_IND_UNLINKED[] = "Disconnected\r\n";
  21          static code unsigned char const BLE_IND_LINKED_TIME_OUT[] = "Timed Out\r\n";
  22          static code unsigned char const BLE_IND_INIT[] = "Initialized\r\n";
  23          static code unsigned char const BLE_IND_PASSWORD[] = "VerificateIdentity\r\n";
  24          static code unsigned char const BLE_IND_UNLOCKED[] = "Please_openthedoor\r\n";
  25          static code unsigned char const BLE_IND_SUCCESS_CHANGE_BLE_NAME[] = "OK";
  26          static code unsigned char const BLE_IND_CONNECT_BREAK[] = "Connection is broken";
  27          
  28          static volatile u8 xdata TX1_Buffer[COM_TX1_Lenth];    //发送缓冲
  29          static volatile u8 xdata RX1_Buffer[COM_RX1_Lenth];    //接收缓冲
  30          
  31          
  32          void init_uart()
  33          {
  34   1          memset(RX1_Buffer, 0, COM_RX1_Lenth);
  35   1          COM1.RX_Cnt = 0;
  36   1          COM1.B_RX_OK = FALSE;
  37   1      }
  38          
  39          void Delay50ms()        //@24.000MHz
  40          {
  41   1          unsigned char i, j, k;
  42   1      
  43   1          _nop_();
  44   1          _nop_();
  45   1          i = 5;
  46   1          j = 144;
  47   1          k = 71;
  48   1          do
  49   1          {
  50   2              do
  51   2              {
  52   3                  while (--k);
  53   3              } while (--j);
  54   2          } while (--i);
  55   1      }
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 2   

  56          
  57          void TX1_write2buff(const u8 dat) 
  58          {
  59   1          TX1_Buffer[COM1.TX_write] = dat;        // 装发送缓冲
  60   1          if(++COM1.TX_write >= COM_TX1_Lenth)    
  61   1              COM1.TX_write = 0;
  62   1      
  63   1          if(COM1.B_TX_busy == 0)                 // 空闲
  64   1          {  
  65   2              COM1.B_TX_busy = 1;                 // 标志忙
  66   2              TI = 1;                             // 触发发送中断
  67   2          }
  68   1      }
  69          
  70          
  71          
  72          static void GetString1(u8 *received) {
  73   1          if (COM1.RX_Cnt) 
  74   1              memcpy(received, RX1_Buffer, COM1.RX_Cnt);
  75   1          received[COM1.RX_Cnt] = '\0';
  76   1          memset(RX1_Buffer, 0, COM_RX1_Lenth);
  77   1          COM1.RX_Cnt = 0;
  78   1          COM1.B_RX_OK = FALSE;
  79   1      }
  80          
  81          static void PrintString1(u8 *puts)
  82          {
  83   1          for (; *puts != 0;  puts++)  TX1_write2buff(*puts);     //遇到停止符0结束
  84   1      }
  85          
  86          static void PrintString2(u8 *puts)
  87          {
  88   1          u8 i;
  89   1          for(i = 0 ; i < 20; i++)
  90   1               TX1_write2buff(puts[i]);
  91   1           Delay50ms();
  92   1      }
  93          void BLE_Init() {
  94   1      
  95   1          memset(TX1_Buffer, 0, COM_TX1_Lenth);
  96   1          memset(RX1_Buffer, 0, COM_RX1_Lenth);
  97   1          USART_Init(&COM1);
  98   1      
  99   1          S1_8bit();
 100   1          S1_BRT_UseTimer2();     // S1 BRT Use Timer2;
 101   1      
 102   1          S1_Int_Enable();        // 允许中断
 103   1      
 104   1          S1_RX_Enable();         // Rx 接收允许
 105   1          S1_USE_P36P37();
 106   1          quasi_bidirectional(BLE_TX_Mx, BLE_TX_BIT);
 107   1          quasi_bidirectional(BLE_RX_Mx, BLE_RX_BIT);
 108   1      
 109   1          S1_TXD_RXD_OPEN();
 110   1      
 111   1          USART_Share_Timer2();
 112   1      }
 113          
 114          void BLE_Enter_Adversting()
 115          {
 116   1          BT_RTS = 0;
 117   1          sync_with_alert();
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 3   

 118   1          ble_send_command("AT+RSET\r\n");
 119   1          Delay50ms();
 120   1          BT_RTS = 1;
 121   1          init_uart();
 122   1      }
 123          
 124          
 125          void BLE_ChangeBLEName(u8 *blename)
 126          {
 127   1          u8 i;
 128   1          u8 cmd[22] = {'A','T','+','S','N','A','M','+', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0
             -x00, 0x00, 0x00,'\r','\n'};
 129   1          for(i = 8; i <= 19; i++)
 130   1              cmd[i] = blename[i-8];
 131   1          BT_RTS = 0;
 132   1          sync_with_alert();
 133   1          for(i = 0; i < 22; i++)
 134   1          {
 135   2              TX1_write2buff(cmd[i]);
 136   2          } 
 137   1          Delay50ms();
 138   1          BT_RTS = 1;
 139   1      }
 140          
 141          bool Check_Requset_for_Read_counter_for_operation(u8 *received)
 142          {
 143   1          u8 i, timestamp[6];
 144   1          for(i = 0; i < 6; i++)
 145   1              timestamp[i] = ~received[i+1];
 146   1          if((received[7] == ~ received[0]) && ChecksimpleCRC(received, 0, 7, received[8]) && 
 147   1              CheckExclusive_Or(timestamp, 0, 5, received, 0, 5, received, 9, 14) && ChecksimpleCRC(received, 7,
             - 14, received[15]) && CheckAnd(received, 0, 7, ~received[16], ~received[17]) && CheckAnd(received, 8, 15, ~received[18],
             - ~received[19]))
 148   1          {
 149   2              return 0;
 150   2          }
 151   1          else
 152   1              return 1;
 153   1      }
 154          
 155          void Send_Response_for_Read_counter_for_operation(u8 *received)
 156          {
 157   1          u8 send_data[20], i, timestamp[6];
 158   1          u32 couter_for_operation;
 159   1          memset(send_data, 0 , 20);
 160   1          send_data[0] = received[0] + 1;
 161   1          if(!Check_Requset_for_Read_counter_for_operation(received))
 162   1          { 
 163   2              send_data[1] = 0x00;
 164   2              // todo
 165   2              if(received[0] == 0x00){ 
 166   3                  couter_for_operation = Read_Counter_for_Open_key_cabinet();
 167   3              }else if(received[0] == 0x02){
 168   3                  couter_for_operation = Read_Counter_for_Open_flood_door();
 169   3              }else if(received[0] == 0x04){
 170   3                  couter_for_operation = Read_Counter_for_Read_A_and_B();
 171   3              }else if(received[0] == 0x06){
 172   3                  couter_for_operation = Read_Counter_for_Write_A();
 173   3              }else if(received[0] == 0x16){
 174   3                  couter_for_operation = Read_Counter_for_change_BLEname();
 175   3              }
 176   2              // todo
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 4   

 177   2              // 硬件状态
 178   2              // performance_status 
 179   2              send_data[2] = performance_status;
 180   2              // 3~5 位取操作数后三位再取反
 181   2              // 高位在前
 182   2              for(i = 3; i <= 5; i++)
 183   2                  send_data[i] = ~(couter_for_operation >> (8 * (5-i)));
 184   2              // 6~11字节取Timestamp
 185   2              for(i = 0; i < 6; i++)
 186   2                  timestamp[i] = ~received[i+1];
 187   2              for(i = 6; i < 12; i++)
 188   2                  send_data[i] = ~timestamp[i-6];
 189   2              // 12~15
 190   2              Read_A(send_data, 12, 15);
 191   2              Exclusive_Or_Creat(send_data, 12, 15, timestamp, 2, 5, send_data, 12, 15);
 192   2              Complement_Creat(send_data, 12, 15, send_data, 12, 15);
 193   2              // 16~19
 194   2              send_data[16] = CRC_Creat(send_data, 0, 7);
 195   2              send_data[17] = CRC_Creat(send_data, 8, 15);
 196   2              send_data[18] = (u8) (AND_Creat(send_data, 0, 17) >> 8);
 197   2              send_data[19] = (u8) AND_Creat(send_data, 0, 17);
 198   2          }
 199   1          else
 200   1          {
 201   2              send_data[1] = 0x01;
 202   2              for(i = 2; i < 17; i++)
 203   2                  send_data[i] = 0x00;
 204   2              send_data[18] = send_data[19] = error_code;
 205   2          }
 206   1          ble_send_data(send_data);
 207   1      }
 208          
 209          bool Check_Requset_for_Open_floodgate(u8 *received)
 210          {
 211   1          u8 i, list_for_Open_flood_door[4], counter_for_B[4], order_over_creat_for_B[4], timestamp[6];
 212   1          u32 counter_for_Open_flood_door;
 213   1          // 取操作次数
 214   1          counter_for_Open_flood_door = Read_Counter_for_Open_flood_door();
 215   1          list_for_Open_flood_door[0] = (u8) (counter_for_Open_flood_door >> 24);
 216   1          list_for_Open_flood_door[1] = (u8) (counter_for_Open_flood_door >> 16);
 217   1          list_for_Open_flood_door[2] = (u8) (counter_for_Open_flood_door >> 8);
 218   1          list_for_Open_flood_door[3] = (u8) counter_for_Open_flood_door;
 219   1          // 取B
 220   1          Read_B(counter_for_B, 0, 3);
 221   1          Order_Over_Creat(counter_for_B, 0, 3, order_over_creat_for_B, 0, 3);
 222   1          for(i = 0; i < 6; i++)
 223   1              timestamp[i] = ~ received[i+10];
 224   1      
 225   1      
 226   1      
 227   1          if(CheckComplement(list_for_Open_flood_door, 1, 3, received, 1, 3) && CheckExclusive_Or(order_over_cre
             -at_for_B, 0, 3, received, 0, 3,  received, 4, 7) && CheckAnd(counter_for_B, 0, 3, ~received[8], ~received[9]) && Checksi
             -mpleCRC(received, 0, 7, received[16]) && ChecksimpleCRC(received, 8, 15, received[17]) && CheckAnd(received, 0, 17, rece
             -ived[18], received[19]))
 228   1          {
 229   2              Store_Counter_for_Open_flood_door(counter_for_Open_flood_door+1);
 230   2              return 0;
 231   2          }
 232   1          else
 233   1          {
 234   2              return 1;
 235   2          }
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 5   

 236   1      }
 237          void Send_Response_for_Open_floodgate(u8 *received)
 238          {
 239   1          u8 send_data[20] , i , timestamp[6], timestamp_complement[6];
 240   1          memset(send_data, 0 , 20);
 241   1          send_data[0] = 0x09;
 242   1          if(!Check_Requset_for_Open_floodgate(received))
 243   1          { 
 244   2              send_data[1] = 0x00;
 245   2              // todo
 246   2              // 2~7字节取Timestamp
 247   2              for(i = 0; i < 6; i++)
 248   2                  timestamp[i] = ~ received[i+10];
 249   2              for(i = 2; i <= 7; i++ )
 250   2                  send_data[i] = timestamp[i-2];
 251   2              send_data[8] = CRC_Creat(send_data, 0, 7);
 252   2              send_data[9] = ~ send_data[0];
 253   2              send_data[10] = (u8) (~ (AND_Creat(send_data, 0, 7) >> 8));
 254   2              send_data[11] = (u8) (~ AND_Creat(send_data, 0, 7));
 255   2              
 256   2              send_data[12] = (u8) (~ (AND_Creat(send_data, 8, 11) >> 8));
 257   2              send_data[13] = (u8) (~ AND_Creat(send_data, 8, 11));
 258   2              // 14 ~ 19
 259   2              Complement_Creat(send_data, 2, 7, timestamp_complement, 0, 5);
 260   2              Exclusive_Or_Creat(timestamp_complement, 0, 5, send_data, 8, 13, send_data, 14, 19);
 261   2              ble_send_data(send_data);
 262   2              // 5S内开锁信号
 263   2              // 开锁(持续一秒的高电平)
 264   2              // candidate_time_out_signal_recieving = NO;
 265   2              // reset_all_counters();
 266   2              // candidate_driver_signal_recieving = YES;
 267   2              // DRIVER = 1;
 268   2          }
 269   1          else
 270   1          {
 271   2              send_data[1] = 0x01;
 272   2              for(i = 2; i < 17; i++)
 273   2                  send_data[i] = 0x00;
 274   2              send_data[18] = send_data[19] = error_code;
 275   2              ble_send_data(send_data);
 276   2          }
 277   1      
 278   1      }
 279          
 280          bool Check_Requset_for_Open_key_cabinet(u8 *received)
 281          {
 282   1          u8 timestamp[6] , i, list_for_Open_key_cabinet[4], counter_for_B[4], order_over_creat_for_B[4];
 283   1          u32 counter_for_Open_key_cabinet;
 284   1          // 取操作次数
 285   1           counter_for_Open_key_cabinet = Read_Counter_for_Open_key_cabinet();
 286   1           list_for_Open_key_cabinet[0] = counter_for_Open_key_cabinet >> 24;
 287   1           list_for_Open_key_cabinet[1] = counter_for_Open_key_cabinet >> 16;
 288   1           list_for_Open_key_cabinet[2] = counter_for_Open_key_cabinet >> 8;
 289   1           list_for_Open_key_cabinet[3] = counter_for_Open_key_cabinet ;
 290   1          // 取B
 291   1          Read_B(counter_for_B, 0, 3);
 292   1          Order_Over_Creat(counter_for_B, 0, 3, order_over_creat_for_B, 0, 3);
 293   1          for(i = 0; i < 6; i++)
 294   1              timestamp[i] = ~ received[i+10];
 295   1          // 第8字节柜门编号
 296   1          key_cabinet_number = (~received[8]) + 1;
 297   1          if(CheckComplement(list_for_Open_key_cabinet, 1, 3, received, 1, 3) && CheckExclusive_Or(order_over_cr
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 6   

             -eat_for_B, 0, 3, received, 0, 3,  received, 4, 7) && (received[9] == ((~ received[8]) ^ received[3])) && ChecksimpleCRC(
             -received, 0, 7, received[16]) && ChecksimpleCRC(received, 8, 15, received[17]) && CheckAnd(received, 0, 17, received[18]
             -, received[19]))
 298   1          {
 299   2              Store_Counter_for_Open_key_cabinet(counter_for_Open_key_cabinet + 1);  
 300   2              return 0;
 301   2          }
 302   1          else
 303   1              return 1;
 304   1      
 305   1      }
 306          void Send_Response_for_Open_key_cabinet(u8 *received)
 307          {
 308   1          u8 send_data[20] , i , timestamp[6], timestamp_complement[6];
 309   1          memset(send_data, 0 , 20);
 310   1          send_data[0] = 0x0C;
 311   1          if(!Check_Requset_for_Open_key_cabinet(received))
 312   1          { 
 313   2              send_data[1] = 0x00;
 314   2              // todo
 315   2              // 2~7字节取Timestamp
 316   2              for(i = 0; i < 6; i++)
 317   2              timestamp[i] = ~ received[i+10];
 318   2              for(i = 2; i <= 7; i++ )
 319   2                  send_data[i] = timestamp[i-2];
 320   2              send_data[8] = CRC_Creat(send_data, 0, 7);
 321   2              send_data[9] = (~ send_data[0]) ^ (~ received[8]);
 322   2              send_data[10] = (u8) (~ (AND_Creat(send_data, 0, 7) >> 8));
 323   2              send_data[11] = (u8) (~ AND_Creat(send_data, 0, 7));
 324   2              
 325   2              send_data[12] = (u8) (~ (AND_Creat(send_data, 8, 11) >> 8));
 326   2              send_data[13] = (u8) (~ AND_Creat(send_data, 8, 11));
 327   2              // 14 ~ 19
 328   2              Complement_Creat(send_data, 2, 7, timestamp_complement, 0, 5);
 329   2              Exclusive_Or_Creat(timestamp_complement, 0, 5, send_data, 8, 13, send_data, 14, 19);
 330   2              ble_send_data(send_data);
 331   2              // 开柜门
 332   2              // 开锁(持续0.3秒的高电平)
 333   2              if(key_cabinet_number == 29 || key_cabinet_number == 30)
 334   2              {
 335   3                  candidate_driver_signal_recieving = YES;
 336   3                  driver_high_pin(key_cabinet_number);
 337   3              }
 338   2              else
 339   2              {
 340   3                  putchar(key_cabinet_number);
 341   3              }
 342   2          }
 343   1          else
 344   1          {
 345   2              send_data[1] = 0x01;
 346   2              for(i = 2; i < 17; i++)
 347   2                  send_data[i] = 0x00;
 348   2              send_data[18] = send_data[19] = error_code;
 349   2              ble_send_data(send_data);
 350   2          }
 351   1      
 352   1          
 353   1      }
 354          
 355          
 356          bool Check_Requset_for_Read_A_and_B(u8 *received)
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 7   

 357          {
 358   1          u8 i, list_for_Read_A_and_B[4], timestamp[6];
 359   1          u32 counter_for_Read_A_and_B;
 360   1          // 取操作次数
 361   1          counter_for_Read_A_and_B = Read_Counter_for_Read_A_and_B();
 362   1          list_for_Read_A_and_B[0] = counter_for_Read_A_and_B >> 24;
 363   1          list_for_Read_A_and_B[1] = counter_for_Read_A_and_B >> 16;
 364   1          list_for_Read_A_and_B[2] = counter_for_Read_A_and_B >> 8;
 365   1          list_for_Read_A_and_B[3] = counter_for_Read_A_and_B;
 366   1          for(i = 0; i < 6; i++)
 367   1              timestamp[i] = ~ received[i+4];
 368   1          if(CheckComplement(list_for_Read_A_and_B, 1, 3, received, 1, 3) && CheckExclusive_Or(timestamp, 0, 5, 
             -received, 0, 5, received, 10, 15) && ChecksimpleCRC(received, 0, 7, received[16]) && ChecksimpleCRC(received, 8, 15, rec
             -eived[17]) && CheckAnd(received, 0, 17, received[18], received[19]))
 369   1          {
 370   2              // Store_Timestamp(timestamp, 0, 5);
 371   2              Store_Counter_for_Read_A_and_B(counter_for_Read_A_and_B + 1);
 372   2              return 0;
 373   2          }
 374   1          else
 375   1              return 1;
 376   1      }
 377          void Send_Response_for_Read_A_and_B(u8 *received)
 378          {
 379   1          u8 send_data[20], i, timestamp[6];
 380   1          memset(send_data, 0 , 20);
 381   1          send_data[0] = 0x0F;
 382   1          if(!Check_Requset_for_Read_A_and_B(received))
 383   1          { 
 384   2              send_data[1] = 0x00;
 385   2              // todo
 386   2              // 2~7字节取Timestamp
 387   2              for(i = 0; i < 6; i++)
 388   2                  timestamp[i] = ~ received[i+4];
 389   2              for(i = 2; i <= 7; i++ )
 390   2                  send_data[i] = timestamp[i-2];
 391   2              Read_A(send_data, 8, 11);
 392   2              Read_B(send_data, 12, 15);
 393   2              // 8 ~ 11
 394   2              Exclusive_Or_Creat(send_data, 8, 11, send_data, 4, 7, send_data, 8, 11);
 395   2              Complement_Creat(send_data, 8, 11, send_data, 8, 11);
 396   2              // 12 ~ 15
 397   2              Exclusive_Or_Creat(send_data, 12, 15, send_data, 0, 3, send_data, 12, 15);
 398   2              Complement_Creat(send_data, 12, 15, send_data, 12, 15);
 399   2              send_data[16] = CRC_Creat(send_data, 0, 7);
 400   2              send_data[17] = CRC_Creat(send_data, 8, 15);
 401   2              send_data[18] = (u8) (~ (AND_Creat(send_data, 0, 17) >> 8)) ;
 402   2              send_data[19] = (u8) (~ AND_Creat(send_data, 0, 17));
 403   2          }
 404   1          else
 405   1          {
 406   2              send_data[1] = 0x01;
 407   2              for(i = 2; i < 17; i++)
 408   2                  send_data[i] = 0x00;
 409   2              send_data[18] = send_data[19] = error_code;
 410   2          }
 411   1           ble_send_data(send_data);
 412   1          
 413   1      }
 414          bool Check_Requset_for_Write_A(u8 *received)
 415          {
 416   1          u8 i, list_for_Write_A[4], counter_for_A[4], timestamp[6];
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 8   

 417   1          u32 counter_for_Write_A;
 418   1          // 取操作次数
 419   1          counter_for_Write_A = Read_Counter_for_Write_A();
 420   1          list_for_Write_A[0] = counter_for_Write_A >> 24;
 421   1          list_for_Write_A[1] = counter_for_Write_A >> 16;
 422   1          list_for_Write_A[2] = counter_for_Write_A >> 8;
 423   1          list_for_Write_A[3] = counter_for_Write_A ;
 424   1          for(i = 0; i < 6; i++)
 425   1              timestamp[i] = ~ received[i+4];
 426   1          Complement_Creat(received, 10, 13, counter_for_A, 0, 3);
 427   1          if(CheckComplement(list_for_Write_A, 1, 3, received, 1, 3) && CheckAnd(received, 0, 13, received[14], 
             -received[15]) && ChecksimpleCRC(received, 0, 7, received[16]) && ChecksimpleCRC(received, 8, 15, received[17]) && CheckA
             -nd(received, 0, 17, received[18], received[19]))
 428   1          {
 429   2              Store_A(counter_for_A, 0, 3);
 430   2              Store_Counter_for_Operate_A_B_and_Blename((counter_for_Write_A + 1), 1);
 431   2              return 0;
 432   2          }
 433   1          else
 434   1              return 1;
 435   1      }
 436          void Send_Response_for_Write_A(u8 *received)
 437          {
 438   1          u8 send_data[20], i, counter_for_A[4], timestamp[6];
 439   1          memset(send_data, 0 , 20);
 440   1          send_data[0] = 0x11;
 441   1          if(!Check_Requset_for_Write_A(received))
 442   1          { 
 443   2              send_data[1] = 0x00;
 444   2              // todo
 445   2              for(i = 0; i < 6; i++)
 446   2                 timestamp[i] = ~ received[i+4];
 447   2              // 2~7字节取Timestamp
 448   2              for(i = 2; i <= 7; i++ )
 449   2                  send_data[i] = timestamp[i-2];
 450   2              // 
 451   2              Complement_Creat(received, 10, 13, counter_for_A, 0, 3);
 452   2              // 8 ~ 11
 453   2              Exclusive_Or_Creat(counter_for_A, 0, 3, send_data, 4, 7, send_data, 8, 11);
 454   2              Complement_Creat(send_data, 8, 11, send_data, 8, 11);
 455   2              // 12 ~ 15
 456   2              Exclusive_Or_Creat(counter_for_A, 0, 3, send_data, 0, 3, send_data, 12, 15);
 457   2              Complement_Creat(send_data, 12, 15, send_data, 12, 15);
 458   2              send_data[16] = CRC_Creat(send_data, 0, 7);
 459   2              send_data[17] = CRC_Creat(send_data, 8, 15);
 460   2              send_data[18] = (u8) ((~ AND_Creat(send_data, 0, 17)) >> 8);
 461   2              send_data[19] = (u8) (~ AND_Creat(send_data, 0, 17));
 462   2          }
 463   1          else
 464   1          {
 465   2              send_data[1] = 0x01;
 466   2              for(i = 2; i < 17; i++)
 467   2                  send_data[i] = 0x00;
 468   2              send_data[18] = send_data[19] = error_code;
 469   2          }
 470   1          ble_send_data(send_data);
 471   1          
 472   1      }
 473          bool Check_Requset_for_ChangeBLEname(u8 *received)
 474          {
 475   1          u8 list_for_ChangeBLEname[4];
 476   1          u32 counter_for_change_BLEname;
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 9   

 477   1          counter_for_change_BLEname = Read_Counter_for_change_BLEname();
 478   1          list_for_ChangeBLEname[0] = counter_for_change_BLEname >> 24;
 479   1          list_for_ChangeBLEname[1] = counter_for_change_BLEname >> 16;
 480   1          list_for_ChangeBLEname[2] = counter_for_change_BLEname >> 8;
 481   1          list_for_ChangeBLEname[3] = counter_for_change_BLEname;
 482   1          if(CheckComplement(list_for_ChangeBLEname, 1, 3, received, 1, 3) && ChecksimpleCRC(received, 0, 7, rec
             -eived[16]) && ChecksimpleCRC(received, 8, 15, received[17]) && CheckAnd(received, 0, 17, received[18], received[19]))
 483   1          {
 484   2              Store_Counter_for_Operate_A_B_and_Blename((counter_for_change_BLEname + 1), 2);
 485   2              return 0;
 486   2          }
 487   1          else
 488   1              return 1;
 489   1          
 490   1      }
 491          void Send_Response_for_ChangeBLEname(u8 *received)
 492          {
 493   1          u8 send_data[20], i, blename[12];
 494   1          memset(send_data, 0 , 20);
 495   1          send_data[0] = 0x13;
 496   1          if(!Check_Requset_for_ChangeBLEname(received))
 497   1          {    
 498   2              send_data[1] = 0x00;
 499   2              // 2~7字节：电话号码
 500   2              send_data[2] = 0x00;
 501   2              send_data[3] = 0x40;
 502   2              send_data[4] = 0x00;
 503   2              send_data[5] = 0x03;
 504   2              send_data[6] = 0x81;
 505   2              send_data[7] = 0x36;
 506   2              Read_A(send_data, 8, 11);
 507   2              // 8 ~ 11
 508   2              Exclusive_Or_Creat(send_data, 8, 11, send_data, 4, 7, send_data, 8, 11);
 509   2              Complement_Creat(send_data, 8, 11, send_data, 8, 11);
 510   2              // 12 ~ 15
 511   2              Read_A(send_data, 12, 15);
 512   2              Exclusive_Or_Creat(send_data, 12, 15, send_data, 0, 3, send_data, 12, 15);
 513   2              Complement_Creat(send_data, 12, 15, send_data, 12, 15);
 514   2              send_data[16] = CRC_Creat(send_data, 0, 7);
 515   2              send_data[17] = CRC_Creat(send_data, 8, 15);
 516   2              send_data[18] = (u8) ((~ AND_Creat(send_data, 0, 17)) >> 8);
 517   2              send_data[19] = (u8) (~ AND_Creat(send_data, 0, 17));
 518   2              for(i = 4; i <= 15; i++)
 519   2                  blename[i - 4] = received[i];
 520   2              BLE_ChangeBLEName(blename);
 521   2              Delay50ms();
 522   2      
 523   2              ble_send_data(send_data);
 524   2              Delay50ms();
 525   2      
 526   2              BLE_Enter_Adversting();
 527   2          }
 528   1          else
 529   1          {
 530   2              send_data[1] = 0x01;
 531   2              for(i = 2; i < 17; i++)
 532   2                  send_data[i] = 0x00;
 533   2              send_data[18] = send_data[19] = error_code;
 534   2              ble_send_data(send_data);
 535   2          }
 536   1          
 537   1      }
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 10  

 538          
 539          
 540          u32 Read_performance_key_cabinet()
 541          {
 542   1          u8 i, iterator = 0;
 543   1          u32 status_for_key_cabinet = 0;
 544   1          if(number_for_badkey)
 545   1          {
 546   2              for(i = 0; i < 32; i++)
 547   2              {
 548   3                  if((iterator < number_for_badkey) && (i == (order_for_badkey[iterator] - 1)))
 549   3                  {
 550   4                      status_for_key_cabinet = status_for_key_cabinet << 1 | 1;
 551   4                      iterator ++;
 552   4                  }
 553   3                  else 
 554   3                      status_for_key_cabinet = status_for_key_cabinet << 1 | 0;
 555   3              }
 556   2          }
 557   1          return status_for_key_cabinet;
 558   1      }
 559          
 560          
 561          bool Check_Requset_for_Read_status_for_key_cabinet(u8 *received)
 562          {
 563   1          u8 i, timestamp[6];
 564   1          for(i = 0; i < 6; i++)
 565   1              timestamp[i] = ~ received[i+1];
 566   1          if((received[7] == ~ received[0]) && ChecksimpleCRC(received, 0, 7, received[8]) && 
 567   1              CheckExclusive_Or(timestamp, 0, 5, received, 0, 5, received, 9, 14) && ChecksimpleCRC(received, 7,
             - 14, received[15]) && CheckAnd(received, 0, 7, ~received[16], ~received[17]) && CheckAnd(received, 8, 15, ~received[18],
             - ~received[19]))
 568   1          {
 569   2              return 0;
 570   2          }
 571   1          else
 572   1              return 1;   
 573   1      }
 574          
 575          void Send_Response_for_Read_status_for_key_cabinet(u8 *received)
 576          {
 577   1          u8 send_data[20], i;
 578   1          u32 status_for_key_cabinet = Read_performance_key_cabinet();
 579   1          memset(send_data, 0 , 20);
 580   1          send_data[0] = 0x15;
 581   1          if(!Check_Requset_for_Read_status_for_key_cabinet(received))
 582   1          { 
 583   2              send_data[1] = 0x00;
 584   2              // todo
 585   2              // 开柜门次数最后一位取反;
 586   2              send_data[2] = ~((u8)(Read_Counter_for_Open_key_cabinet()));
 587   2      
 588   2              // 柜门状态
 589   2              // for(code_key_cabinet = 3; code_key_cabinet < 15; code_key_cabinet++)
 590   2              //     for(i = 0; i < 8; i++)
 591   2              //         send_data[code_key_cabinet] =send_data[code_key_cabinet] << 1 | Read_status_key_cabinet
             -(code_key_cabinet);
 592   2              send_data[3] = status_for_key_cabinet >> 24;
 593   2              send_data[4] = status_for_key_cabinet >> 16;
 594   2              send_data[5] = status_for_key_cabinet >> 8;
 595   2              send_data[6] = status_for_key_cabinet;
 596   2              send_data[12] = send_data[13] = send_data[14] = send_data[15] = send_data[7] = send_data[8] = send
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 11  

             -_data[9] = send_data[10] = send_data[11] = 0x00;
 597   2              send_data[16] = CRC_Creat(send_data, 0, 7);
 598   2              send_data[17] = CRC_Creat(send_data, 8, 15);
 599   2              send_data[18] = (u8) (AND_Creat(send_data, 0, 17) >> 8);
 600   2              send_data[19] = (u8) AND_Creat(send_data, 0, 17);
 601   2          }
 602   1          else
 603   1          {
 604   2              send_data[1] = 0x01;
 605   2              for(i = 2; i < 17; i++)
 606   2                  send_data[i] = 0x00;
 607   2              send_data[18] = send_data[19] = error_code;
 608   2          }
 609   1          ble_send_data(send_data); 
 610   1      }
 611          
 612          
 613          bool Check_Requset_for_Read_performance_for_key_cabinet(u8 *received)
 614          {
 615   1          u8 i, timestamp[6];
 616   1          for(i = 0; i < 6; i++)
 617   1              timestamp[i] = ~ received[i+1];
 618   1          if((received[7] == ~ received[0]) && ChecksimpleCRC(received, 0, 7, received[8]) && 
 619   1              CheckExclusive_Or(timestamp, 0, 5, received, 0, 5, received, 9, 14) && ChecksimpleCRC(received, 7,
             - 14, received[15]) && CheckAnd(received, 0, 7, ~received[16], ~received[17]) && CheckAnd(received, 8, 15, ~received[18],
             - ~received[19]))
 620   1          {
 621   2              return 0;
 622   2          }
 623   1          else
 624   1              return 1;   
 625   1      }
 626          
 627          void Send_Response_for_Read_performance_for_key_cabinet(u8 *received)
 628          {
 629   1          u8 send_data[20], i;
 630   1          u32 performance_for_key_cabinet = ~ Read_performance_key_cabinet();
 631   1          memset(send_data, 0 , 20);
 632   1          send_data[0] = 0x19;
 633   1          if(!Check_Requset_for_Read_performance_for_key_cabinet(received))
 634   1          { 
 635   2              send_data[1] = 0x00;
 636   2              send_data[2] = ~((u8)(Read_Counter_for_Open_key_cabinet()));
 637   2              // for(code_key_cabinet = 3; code_key_cabinet < 15; code_key_cabinet++)
 638   2              //     for(i = 0; i < 8; i++)
 639   2              //         send_data[code_key_cabinet] =send_data[code_key_cabinet] << 1 | Read_status_key_cabinet
             -(code_key_cabinet);
 640   2              send_data[3] = performance_for_key_cabinet >> 24;
 641   2              send_data[4] = performance_for_key_cabinet >> 16;
 642   2              send_data[5] = performance_for_key_cabinet >> 8;
 643   2              send_data[6] = performance_for_key_cabinet;
 644   2              send_data[12] = send_data[13] = send_data[14] = send_data[15] = send_data[7] = send_data[8] = send
             -_data[9] = send_data[10] = send_data[11] = 0xff;
 645   2      
 646   2              send_data[16] = CRC_Creat(send_data, 0, 7);
 647   2              send_data[17] = CRC_Creat(send_data, 8, 15);
 648   2              send_data[18] = (u8) (AND_Creat(send_data, 0, 17) >> 8);
 649   2              send_data[19] = (u8) AND_Creat(send_data, 0, 17);
 650   2          }
 651   1          else
 652   1          {
 653   2              send_data[1] = 0x01;
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 12  

 654   2              for(i = 2; i < 17; i++)
 655   2                  send_data[i] = 0x00;
 656   2              send_data[18] = send_data[19] = error_code;
 657   2          }
 658   1          ble_send_data(send_data); 
 659   1      }
 660          
 661          void handle_uart_data(){
 662   1          unsigned char received[32];
 663   1          ble_recieve_data(received);
 664   1          if((received[0] >= 65 && received[0] <= 90) || (received[0] >= 97 && received[0] <= 122)){
 665   2              request_process_recieved(received);
 666   2          } else {
 667   2              ble_process_recieved(received);
 668   2          }
 669   1      }
 670          
 671          void ble_process_recieved(char *received) {
 672   1          if (strcmp(received, BLE_IND_LINKED) == 0) {
 673   2              // 5s没发数据、断开
 674   2              reset_counter_for_ble();
 675   2              reset_all_counters();
 676   2              candidate_time_out_signal_recieving = YES;
 677   2              // candidate_time_out_signal_recieving = NO;
 678   2          } else if (strcmp(received, BLE_IND_ADVERTISING) == 0) {
 679   2              candidate_time_out_signal_recieving = NO;
 680   2              _nop_();
 681   2          } else if (strcmp(received, BLE_IND_LINKED_TIME_OUT) == 0) {
 682   2              candidate_time_out_signal_recieving = NO;
 683   2              BLE_Enter_Adversting();
 684   2          } else if (strcmp(received, BLE_IND_UNLINKED) == 0) {
 685   2              candidate_time_out_signal_recieving = NO;
 686   2              _nop_();
 687   2          } else if (strcmp(received, BLE_IND_INIT) == 0) {
 688   2              candidate_time_out_signal_recieving = NO;
 689   2              _nop_();
 690   2          } else if (strcmp(received, BLE_IND_PASSWORD) == 0) {
 691   2              // 5s内验证通过、不再断开
 692   2              candidate_time_out_signal_recieving = NO;
 693   2              reset_all_counters();
 694   2          } else if (strcmp(received, BLE_IND_UNLOCKED) == 0) {
 695   2              // 5S内开锁信号
 696   2              // 开锁(持续一秒的高电平)
 697   2             // candidate_time_out_signal_recieving = NO;
 698   2             // reset_all_counters();
 699   2             // candidate_driver_signal_recieving = YES;
 700   2             // DRIVER = 1; // 开锁
 701   2          } else if(strcmp(received, BLE_IND_SUCCESS_CHANGE_BLE_NAME) == 0){
 702   2              reset_all_counters();
 703   2              candidate_time_out_signal_recieving = NO;
 704   2              BLE_Enter_Adversting(); 
 705   2          } else {
 706   2              // 错误数据直接断开进入广播模式
 707   2              reset_all_counters();
 708   2              candidate_time_out_signal_recieving = NO;
 709   2              BLE_Enter_Adversting();
 710   2          }
 711   1      }
 712          
 713          void request_process_recieved(char *received)
 714          {
 715   1          if(received[0] == 0x00 || received[0] == 0x02 || received[0] == 0x04 || received[0] == 0x06 || receive
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 13  

             -d[0] == 0x16){
 716   2              candidate_time_out_signal_recieving = NO;
 717   2              reset_all_counters();
 718   2              Send_Response_for_Read_counter_for_operation(received);
 719   2          }else if(received[0] == 0x08){
 720   2              candidate_time_out_signal_recieving = NO;
 721   2              reset_all_counters();
 722   2              Send_Response_for_Open_floodgate(received);
 723   2          }else if(received[0] == 0x0B){
 724   2              candidate_time_out_signal_recieving = NO;
 725   2              reset_all_counters();
 726   2              Send_Response_for_Open_key_cabinet(received);
 727   2          }else if(received[0] == 0x0E){
 728   2              candidate_time_out_signal_recieving = NO;
 729   2              reset_all_counters();
 730   2              Send_Response_for_Read_A_and_B(received);
 731   2          }else if(received[0] == 0x10){
 732   2              candidate_time_out_signal_recieving = NO;
 733   2              reset_all_counters();
 734   2              Send_Response_for_Write_A(received);
 735   2          }else if(received[0] == 0x12){
 736   2              candidate_time_out_signal_recieving = NO;
 737   2              reset_all_counters();   
 738   2              Send_Response_for_ChangeBLEname(received);
 739   2          }else if(received[0] == 0x14){
 740   2              candidate_time_out_signal_recieving = NO;
 741   2              reset_all_counters();
 742   2              Send_Response_for_Read_status_for_key_cabinet(received);
 743   2          }else if(received[0] == 0x18){
 744   2              candidate_time_out_signal_recieving = NO;
 745   2              reset_all_counters();
 746   2              Send_Response_for_Read_performance_for_key_cabinet(received);
 747   2          }else{
 748   2              // 错误数据
 749   2              reset_all_counters();
 750   2              candidate_time_out_signal_recieving = NO;
 751   2              BLE_Enter_Adversting();
 752   2          }
 753   1      
 754   1      }
 755          // Handle usart trigger: receiving "\r\n"
 756          void UART1_int (void) interrupt UART1_VECTOR
 757          {
 758   1          if(RI)
 759   1          {
 760   2              RI = 0;
 761   2              if(COM1.B_RX_OK == 0)
 762   2              {
 763   3                  if (COM1.RX_Cnt >= COM_RX1_Lenth)
 764   3                      COM1.RX_Cnt = 0;
 765   3                  RX1_Buffer[COM1.RX_Cnt++] = SBUF;
 766   3                  COM1.RX_TimeOut = TimeOutSet1;
 767   3              }
 768   2      
 769   2          }
 770   1      
 771   1          if(TI)
 772   1          {
 773   2              TI = 0;
 774   2              if(COM1.TX_read != COM1.TX_write)
 775   2              {
 776   3                  SBUF = TX1_Buffer[COM1.TX_read];
C51 COMPILER V9.52.0.0   BLE                                                               02/29/2016 20:28:49 PAGE 14  

 777   3                  if(++COM1.TX_read >= COM_TX1_Lenth)     
 778   3                      COM1.TX_read = 0;
 779   3              }
 780   2              else    
 781   2                  COM1.B_TX_busy = 0;
 782   2          }
 783   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8433    ----
   CONSTANT SIZE    =    165    ----
   XDATA SIZE       =     96     459
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
