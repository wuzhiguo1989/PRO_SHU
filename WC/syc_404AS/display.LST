C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN display.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE display.c COMPACT OMF2 OPTIMIZE(9,SPEED) BROWSE DEBUG TABS(2)

line level    source

   1          #include "shared.h"
   2          #include "display.h"
   3          #include "sync.h"
   4          #include "def.h"
   5          #include "intrins.h"
   6          // ------------------------- display config declaring -------------------------
   7          
   8          
   9          // 1
  10          static code u16 const 
  11          cycle_for_0001[12]= {476, 500, 200, 70, 70, 70, 70, 70, 70, 70, 490, 10};
  12          // 2
  13          static code u16 const 
  14          // cycle_for_0010[3] = {1, 2, 2};
  15          cycle_for_0010[2] = {2, 2};
  16          // 3
  17          static code u16 const 
  18          cycle_for_0011[15] = {41, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 55, 10};
  19          // 4
  20          static code u16 const 
  21          cycle_for_0100[3] = {476, 490, 10};
  22          // 5
  23          static code u16 const 
  24          cycle_for_0101[13] = {11, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 90, 10};
  25          // 6
  26          static code u16 const 
  27          cycle_for_0110[3] = {176, 190, 10};
  28          // 7
  29          static code u16 const 
  30          cycle_for_0111[5] = {76, 100, 100, 290, 10};
  31          // 8
  32          static code u16 const 
  33          cycle_for_1000[24] = {41, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 260, 65, 65, 65, 65, 65, 65,
             - 65, 190, 10};
  34          // 9
  35          static code u16 const 
  36          cycle_for_1001[26] = {476, 500, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 200, 65, 65, 65, 6
             -5, 65, 65, 65, 190, 10};
  37          // 10
  38          static code u16 const 
  39          cycle_for_1010[13] = {16, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 510, 10};
  40          // 11
  41          static code u16 const 
  42          cycle_for_1011[3] ={296, 310, 10};
  43          // 12
  44          static code u16 const
  45          cycle_for_1100[5] ={36, 60, 60, 150, 10};
  46          
  47          cycle_reached_pt cycle_reached;
  48          static const u16 code * data cycle_params;
  49          static u8 current_interval;
  50          static u8 cycle_counter_for_0010 = 4;
  51          
  52          // ------------------------- display_mode_init declaring -------------------------
  53          static void combination_driver_init();
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 2   

  54          static void driver_0001_init();
  55          static void driver_0010_init();
  56          static void driver_0011_init();
  57          static void driver_0100_init();
  58          static void driver_0101_init();
  59          static void driver_0110_init();
  60          static void driver_0111_init();
  61          static void driver_1000_init();
  62          static void driver_1001_init();
  63          static void driver_1010_init();
  64          static void driver_1011_init();
  65          static void driver_1100_init();
  66          static void driver_1101_init();
  67          
  68          // ------------------------- cycle_reached declaring ---------------------------
  69          static void cycle_reached_0001(u16);
  70          static void cycle_reached_0010(u16);
  71          static void cycle_reached_0011(u16);
  72          static void cycle_reached_0100(u16);
  73          static void cycle_reached_0101(u16);
  74          static void cycle_reached_0110(u16);
  75          static void cycle_reached_0111(u16);
  76          static void cycle_reached_1000(u16);
  77          static void cycle_reached_1001(u16);
  78          static void cycle_reached_1010(u16);
  79          static void cycle_reached_1011(u16);
  80          static void cycle_reached_1100(u16);
  81          
  82          void
  83          toggle_once() {
  84   1        // todo
  85   1        if(cycle_output[0] == ON) P36 = 1;
  86   1        else P36 = 0;
  87   1        if(cycle_output[1] == ON) P37 = 1;
  88   1        else  P37 = 0;
  89   1      }
  90          void 
  91          cycle_based_adjust(const u16 cycle) {
  92   1          cycle_reached(cycle);
  93   1      }
  94          
  95          void 
  96          display_mode_set_changed() {
  97   1        // DON't trig display_mode_logic_changed()
  98   1        // -> sync.h
  99   1      //  cycle_ctrl_disable();
 100   1        //display_mode_logic = display_mode_set;
 101   1        // 1. driver init
 102   1        // 2. display_driver -> detailed
 103   1        // 3. cycle_params -> detailed
 104   1        switch (display_mode_set) {
 105   2          case combination:
 106   2            combination_driver_init();
 107   2            // display_mode_logic will never be combination
 108   2            // don't set display driver -> combination driver
 109   2            // don't set cycle_params -> any
 110   2            break;
 111   2          case flash1_directional: 
 112   2            driver_0001_init();
 113   2            cycle_params = cycle_for_0001;
 114   2            cycle_reached = cycle_reached_0001;
 115   2            break;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 3   

 116   2          case flash2_directional: 
 117   2            driver_0010_init();
 118   2            cycle_params = cycle_for_0010;
 119   2            cycle_reached = cycle_reached_0010;
 120   2            break;
 121   2          case random_fade: 
 122   2            driver_0011_init();
 123   2            cycle_params = cycle_for_0011;
 124   2            cycle_reached = cycle_reached_0011;
 125   2            break;
 126   2          case stacking_flash: 
 127   2            driver_0100_init();
 128   2            cycle_params = cycle_for_0100;
 129   2            cycle_reached = cycle_reached_0100;
 130   2            break;
 131   2          case flash_and_chase: 
 132   2            driver_0101_init();
 133   2            cycle_params = cycle_for_0101;
 134   2            cycle_reached = cycle_reached_0101;
 135   2            break;
 136   2          case random_flashing: 
 137   2            driver_0110_init();
 138   2            cycle_params = cycle_for_0110;
 139   2            cycle_reached = cycle_reached_0110;
 140   2            break;
 141   2          case bi_directional_pulsing: 
 142   2            driver_0111_init();
 143   2            cycle_params = cycle_for_0111;
 144   2            cycle_reached = cycle_reached_0111;
 145   2            break;
 146   2          case bi_directional_chasing: 
 147   2            driver_1000_init();
 148   2            cycle_params = cycle_for_1000;
 149   2            cycle_reached = cycle_reached_1000;
 150   2            break;
 151   2          case pulsing: 
 152   2            driver_1001_init();
 153   2            cycle_params = cycle_for_1001;
 154   2            cycle_reached = cycle_reached_1001;
 155   2            break;
 156   2          case steady_flash: 
 157   2            driver_1010_init();
 158   2            cycle_params = cycle_for_1010;
 159   2            cycle_reached = cycle_reached_1010;
 160   2            break;
 161   2          case sequential_flashing: 
 162   2            driver_1011_init();
 163   2            cycle_params = cycle_for_1011;
 164   2            cycle_reached = cycle_reached_1011;
 165   2            break;
 166   2          case progressive_strobing: 
 167   2            driver_1100_init();
 168   2            cycle_params = cycle_for_1100;
 169   2            cycle_reached = cycle_reached_1100;
 170   2            break;
 171   2          case bi_directional_storbing:
 172   2            driver_1101_init();
 173   2          default:
 174   2            break; 
 175   2        }
 176   1        reset_all_counters();
 177   1        // -> sync.h
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 4   

 178   1       // cycle_ctrl_enable();
 179   1      }
 180          
 181          // called by pca_isr (combination rotation)
 182          // called by com_isr (combination init)
 183          void 
 184          display_mode_logic_changed() {
 185   1        // 1. driver init
 186   1        // 2. display_driver -> detailed
 187   1        // 3. cycle_params -> detailed
 188   1        // -> sync.h
 189   1        //cycle_ctrl_disable();
 190   1        switch (display_mode_logic) {
 191   2          case combination:
 192   2            break;
 193   2          case flash1_directional: 
 194   2            driver_0001_init();
 195   2            cycle_params = cycle_for_0001;
 196   2            cycle_reached = cycle_reached_0001;
 197   2            break;
 198   2          case flash2_directional: 
 199   2            driver_0010_init();
 200   2            cycle_params = cycle_for_0010;
 201   2            cycle_reached = cycle_reached_0010;
 202   2            break;
 203   2          case random_fade: 
 204   2            driver_0011_init();
 205   2            cycle_params = cycle_for_0011;
 206   2            cycle_reached = cycle_reached_0011;
 207   2            break;
 208   2          case stacking_flash: 
 209   2            driver_0100_init();
 210   2            cycle_params = cycle_for_0100;
 211   2            cycle_reached = cycle_reached_0100;
 212   2            break;
 213   2          case flash_and_chase: 
 214   2            driver_0101_init();
 215   2            cycle_params = cycle_for_0101;
 216   2            cycle_reached = cycle_reached_0101;
 217   2            break;
 218   2          case random_flashing: 
 219   2            driver_0110_init();
 220   2            cycle_params = cycle_for_0110;
 221   2            cycle_reached = cycle_reached_0110;
 222   2            break;
 223   2          case bi_directional_pulsing: 
 224   2            driver_0111_init();
 225   2            cycle_params = cycle_for_0111;
 226   2            cycle_reached = cycle_reached_0111;
 227   2            break;
 228   2          case bi_directional_chasing: 
 229   2            driver_1000_init();
 230   2            cycle_params = cycle_for_1000;
 231   2            cycle_reached = cycle_reached_1000;
 232   2            break;
 233   2          case pulsing: 
 234   2            driver_1001_init();
 235   2            cycle_params = cycle_for_1001;
 236   2            cycle_reached = cycle_reached_1001;
 237   2            break;
 238   2          case steady_flash: 
 239   2            driver_1010_init();
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 5   

 240   2            cycle_params = cycle_for_1010;
 241   2            cycle_reached = cycle_reached_1010;
 242   2            break;
 243   2          case sequential_flashing: 
 244   2            driver_1011_init();
 245   2            cycle_params = cycle_for_1011;
 246   2            cycle_reached = cycle_reached_1011;
 247   2            break;
 248   2          case progressive_strobing: 
 249   2            driver_1100_init();
 250   2            cycle_params = cycle_for_1100;
 251   2            cycle_reached = cycle_reached_1100;
 252   2            break;
 253   2          case bi_directional_storbing:
 254   2          //  driver_1101_init();
 255   2          default:
 256   2            break; 
 257   2        }
 258   1        reset_counter_for_cycle();
 259   1        // override flag -> YES:  (slow)fade-in-out
 260   1        // override flag -> NO:   else
 261   1      }
 262          
 263          // 0
 264          static void
 265          combination_driver_init() {
 266   1        // cycle_output[0] = ON;
 267   1        // cycle_output[1] = ON;
 268   1        P36 = 1;
 269   1        P37 = 1;
 270   1        cycle_finished = NO;
 271   1        P33 = 0;
 272   1        current_interval = 0;
 273   1        display_mode_logic_changed();
 274   1      }
 275          // 13
 276          static void
 277          driver_1101_init()
 278          {
 279   1        // cycle_output[0] = ON;
 280   1        // cycle_output[1] = ON;
 281   1        P36 = 1;
 282   1        P37 = 1;
 283   1        cycle_finished = NO;
 284   1        P33 = 0;
 285   1        current_interval = 0;
 286   1        //display_mode_logic = 2;
 287   1        display_mode_logic_changed();
 288   1      }
 289          
 290          // 1
 291          static void
 292          driver_0001_init() {
 293   1        current_interval = 0;
 294   1        P33 = 0;
 295   1      //  cycle_output[0] = ON;
 296   1      //  cycle_output[1] = OFF;
 297   1        P36 = 1;
 298   1        P37 = 0;
 299   1      }
 300          
 301          
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 6   

 302          static void 
 303          cycle_reached_0001(u16 cycle) 
 304          {
 305   1        if(cycle >= cycle_params[current_interval])
 306   1        {
 307   2          if(current_interval == 0){
 308   3            // cycle_output[0] = OFF;
 309   3            // cycle_output[1] = ON;
 310   3            P36 = 0;
 311   3            P37 = 1;
 312   3          }
 313   2          else if(current_interval == 1){
 314   3            // cycle_output[0] = OFF;
 315   3            // cycle_output[1] = OFF;
 316   3            P36 = 0;
 317   3            P37 = 0;
 318   3          }
 319   2          else if(current_interval == 2){
 320   3            // cycle_output[0] = ON;
 321   3            // cycle_output[1] = ON;
 322   3            P36 = 1;
 323   3            P37 = 1;
 324   3          }
 325   2          else if(current_interval == 3){
 326   3            // cycle_output[0] = OFF;
 327   3            // cycle_output[1] = OFF;
 328   3            P36 = 0;
 329   3            P37 = 0;
 330   3          }
 331   2          else if(current_interval == 4){
 332   3            // cycle_output[0] = ON;
 333   3            // cycle_output[1] = ON;
 334   3            P36 = 1;
 335   3            P37 = 1;
 336   3          }
 337   2          else if(current_interval == 5){
 338   3            // cycle_output[0] = OFF;
 339   3            // cycle_output[1] = OFF;
 340   3            P36 = 0;
 341   3            P37 = 0;
 342   3          }
 343   2          else if(current_interval == 6){
 344   3            // cycle_output[0] = ON;
 345   3            // cycle_output[1] = ON;
 346   3            P36 = 1;
 347   3            P37 = 1;
 348   3          }
 349   2          else if(current_interval == 7){
 350   3            // cycle_output[0] = OFF;
 351   3            // cycle_output[1] = OFF;
 352   3            P36 = 0;
 353   3            P37 = 0;
 354   3          }
 355   2          else if(current_interval == 8){
 356   3            // cycle_output[0] = ON;
 357   3            // cycle_output[1] = ON;
 358   3            P36 = 1;
 359   3            P37 = 1;
 360   3          }
 361   2          else if(current_interval == 9){
 362   3            // cycle_output[0] = OFF;
 363   3            // cycle_output[1] = OFF;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 7   

 364   3            P36 = 0;
 365   3            P37 = 0;
 366   3          }
 367   2          else if(current_interval == 10){
 368   3            // cycle_output[0] = ON;
 369   3            // cycle_output[1] = OFF;
 370   3            P33 = 1;
 371   3          }
 372   2          else if(current_interval == 11){
 373   3            // cycle_output[0] = ON;
 374   3            // cycle_output[1] = OFF;
 375   3            P36 = 1;
 376   3            P37 = 0;
 377   3            P33 = 0;
 378   3          }
 379   2          // else if(current_interval == 10){
 380   2          //  // cycle_output[0] = ON;
 381   2          //  // cycle_output[1] = OFF;
 382   2          //  P36 = 1;
 383   2          //  P37 = 0;
 384   2          // }
 385   2          reset_counter_for_cycle();
 386   2          ++ current_interval;
 387   2          // if(current_interval == 11)
 388   2          // {
 389   2          //  current_interval = 0;
 390   2          //  cycle_finished = YES;
 391   2          // }
 392   2          if(current_interval == 12)
 393   2          {
 394   3            current_interval = 0;
 395   3          }
 396   2        }
 397   1      }
 398          
 399          // 2
 400          static void
 401          driver_0010_init() {
 402   1        current_interval = 0;
 403   1        cycle_finished = NO;
 404   1        P33 = 0;
 405   1        cycle_counter_for_0010 = 4;
 406   1        // cycle_output[0] = ON;
 407   1        // cycle_output[1] = ON;
 408   1        P36 = 1;
 409   1        P37 = 1;
 410   1      }
 411          
 412          static void 
 413          cycle_reached_0010(u16 cycle) 
 414          {
 415   1        if(cycle >= cycle_params[current_interval])
 416   1        {
 417   2          if(current_interval == 0){
 418   3            // cycle_output[0] = OFF;
 419   3            // cycle_output[1] = OFF;
 420   3            P36 = 0;
 421   3            P37 = 0;
 422   3          }
 423   2          // else if(current_interval == 1){
 424   2          //  // cycle_output[0] = ON;
 425   2          //  // cycle_output[1] = OFF;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 8   

 426   2          //  P33 = 1;
 427   2          // }
 428   2          // else if(current_interval == 2){
 429   2          //  // cycle_output[0] = ON;
 430   2          //  // cycle_output[1] = OFF;
 431   2          //  P36 = 1;
 432   2          //  P37 = 1;
 433   2          //  P33 = 0;
 434   2          // }
 435   2          else if(current_interval == 1){
 436   3            // cycle_output[0] = ON;
 437   3            // cycle_output[1] = ON;
 438   3            P36 = 1;
 439   3            P37 = 1;
 440   3          }
 441   2      
 442   2          reset_counter_for_cycle();
 443   2          ++ current_interval;
 444   2      //    if(current_interval == 3)
 445   2           if(current_interval == 2)
 446   2          {
 447   3            current_interval = 0;
 448   3            cycle_finished = NO;
 449   3            --cycle_counter_for_0010;
 450   3            if(!cycle_counter_for_0010)
 451   3            {
 452   4              cycle_counter_for_0010 = 4;
 453   4              if(display_mode_set == combination)
 454   4              {
 455   5                display_mode_logic = 3;
 456   5                display_mode_logic_changed();
 457   5              }
 458   4      
 459   4            }
 460   3          }
 461   2        }
 462   1      }
 463          // 3
 464          static void
 465          driver_0011_init() {
 466   1        current_interval = 0;
 467   1        cycle_finished = NO;
 468   1        // cycle_output[0] = ON;
 469   1        // cycle_output[1] = OFF;
 470   1        P36 = 1;
 471   1        P37 = 0;
 472   1      }
 473          
 474          
 475          static void 
 476          cycle_reached_0011(u16 cycle) {
 477   1        if(cycle >= cycle_params[current_interval])
 478   1        {
 479   2          if(current_interval == 0){
 480   3            // cycle_output[0] = OFF;
 481   3            // cycle_output[1] = OFF;
 482   3            P36 = 0;
 483   3            P37 = 0;
 484   3          }
 485   2          else if(current_interval == 1){
 486   3            // cycle_output[0] = ON;
 487   3            // cycle_output[1] = OFF;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 9   

 488   3            P36 = 1;
 489   3            P37 = 0;
 490   3          }
 491   2          else if(current_interval == 2){
 492   3            // cycle_output[0] = OFF;
 493   3            // cycle_output[1] = OFF;
 494   3            P36 = 0;
 495   3            P37 = 0;
 496   3          }
 497   2          else if(current_interval == 3){
 498   3            // cycle_output[0] = ON;
 499   3            // cycle_output[1] = OFF;
 500   3            P36 = 1;
 501   3            P37 = 0;
 502   3          }
 503   2          else if(current_interval == 4){
 504   3            // cycle_output[0] = OFF;
 505   3            // cycle_output[1] = OFF;
 506   3            P36 = 0;
 507   3            P37 = 0;
 508   3          }
 509   2          else if(current_interval == 5){
 510   3            // cycle_output[0] = ON;
 511   3            // cycle_output[1] = OFF;
 512   3            P36 = 1;
 513   3            P37 = 0;
 514   3          }
 515   2          else if(current_interval == 6){
 516   3            // cycle_output[0] = OFF;
 517   3            // cycle_output[1] = ON;
 518   3            P36 = 0;
 519   3            P37 = 1;
 520   3          }
 521   2          else if(current_interval == 7){
 522   3            // cycle_output[0] = OFF;
 523   3            // cycle_output[1] = OFF;
 524   3            P36 = 0;
 525   3            P37 = 0;
 526   3          }
 527   2          else if(current_interval == 8){
 528   3            // cycle_output[0] = OFF;
 529   3            // cycle_output[1] = ON;
 530   3            P36 = 0;
 531   3            P37 = 1;
 532   3          }
 533   2          else if(current_interval == 9){
 534   3            // cycle_output[0] = OFF;
 535   3            // cycle_output[1] = OFF;
 536   3            P36 = 0;
 537   3            P37 = 0;
 538   3          }
 539   2          else if(current_interval == 10){
 540   3            // cycle_output[0] = OFF;
 541   3            // cycle_output[1] = ON;
 542   3            P36 = 0;
 543   3            P37 = 1;
 544   3          }
 545   2          else if(current_interval == 11){
 546   3            // cycle_output[0] = ON;
 547   3            // cycle_output[1] = ON;
 548   3            P36 = 0;
 549   3            P37 = 0;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 10  

 550   3          }
 551   2          else if(current_interval == 12){
 552   3            // cycle_output[0] = OFF;
 553   3            // cycle_output[1] = ON;
 554   3            P36 = 0;
 555   3            P37 = 1;
 556   3          }
 557   2          else if(current_interval == 13){
 558   3            // cycle_output[0] = ON;
 559   3            // cycle_output[1] = OFF;
 560   3            P33 = 1;
 561   3          }
 562   2          else if(current_interval == 14){
 563   3            // cycle_output[0] = ON;
 564   3            // cycle_output[1] = OFF;
 565   3            P36 = 1;
 566   3            P37 = 0;
 567   3            P33 = 0;
 568   3          }
 569   2          // else if(current_interval == 13){
 570   2          //  // cycle_output[0] = ON;
 571   2          //  // cycle_output[1] = OFF;
 572   2          //  P36 = 1;
 573   2          //  P37 = 0;
 574   2          // }
 575   2          reset_counter_for_cycle();
 576   2          ++ current_interval;
 577   2          if(current_interval == 15)
 578   2          // if(current_interval == 14)
 579   2          {
 580   3            current_interval = 0;
 581   3            // cycle_finished = YES;
 582   3          }
 583   2        }
 584   1      }
 585          
 586          // 4
 587          static void
 588          driver_0100_init() {
 589   1        // cycle_output[0] = ON;
 590   1        // cycle_output[1] = OFF;
 591   1        P36 = 1;
 592   1        P37 = 0;
 593   1        cycle_finished = NO;
 594   1        P33 = 0;
 595   1        current_interval = 0;
 596   1      }
 597          
 598          
 599          static void 
 600          cycle_reached_0100(u16 cycle) {
 601   1      
 602   1        if(cycle >= cycle_params[current_interval])
 603   1        {
 604   2          if(current_interval == 0){
 605   3            // cycle_output[0] = OFF;
 606   3            // cycle_output[1] = ON;
 607   3            P36 = 0;
 608   3            P37 = 1;
 609   3          }
 610   2          else if(current_interval == 1){
 611   3            // cycle_output[0] = ON;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 11  

 612   3            // cycle_output[1] = OFF;
 613   3            P33 = 1;
 614   3          }
 615   2          else if(current_interval == 2){
 616   3            // cycle_output[0] = ON;
 617   3            // cycle_output[1] = OFF;
 618   3            P36 = 1;
 619   3            P37 = 0;
 620   3            P33 = 0;
 621   3          }
 622   2          // else if(current_interval == 1){
 623   2          //  // cycle_output[0] = ON;
 624   2          //  // cycle_output[1] = OFF;
 625   2          //  P36 = 1;
 626   2          //  P37 = 0;
 627   2          // }
 628   2          reset_counter_for_cycle();
 629   2          ++ current_interval;
 630   2          if(current_interval == 3)
 631   2          // if(current_interval == 2)
 632   2          {
 633   3            current_interval = 0;
 634   3            // cycle_finished = YES;
 635   3          }
 636   2        }
 637   1      }
 638          
 639          
 640          // 5
 641          static void
 642          driver_0101_init() {
 643   1        current_interval = 0;
 644   1        cycle_finished = NO;
 645   1        P33 = 0;
 646   1        // cycle_output[0] = ON;
 647   1        // cycle_output[1] = ON;
 648   1        P36 = 1;
 649   1        P37 = 1;
 650   1      }
 651          
 652          
 653          static void 
 654          cycle_reached_0101(u16 cycle) {
 655   1      
 656   1        if(cycle >= cycle_params[current_interval])
 657   1        {
 658   2          if(current_interval == 0){
 659   3            // cycle_output[0] = OFF;
 660   3            // cycle_output[1] = OFF;
 661   3            P36 = 0;
 662   3            P37 = 0;
 663   3          }
 664   2          else if(current_interval == 1){
 665   3            // cycle_output[0] = ON;
 666   3            // cycle_output[1] = ON;
 667   3            P36 = 1;
 668   3            P37 = 1;
 669   3          }
 670   2          else if(current_interval == 2){
 671   3            // cycle_output[0] = OFF;
 672   3            // cycle_output[1] = OFF;
 673   3            P36 = 0;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 12  

 674   3            P37 = 0;
 675   3          }
 676   2          else if(current_interval == 3){
 677   3            // cycle_output[0] = ON;
 678   3            // cycle_output[1] = ON;
 679   3            P36 = 1;
 680   3            P37 = 1;
 681   3          }
 682   2          else if(current_interval == 4){
 683   3            // cycle_output[0] = OFF;
 684   3            // cycle_output[1] = OFF;
 685   3            P36 = 0;
 686   3            P37 = 0;
 687   3          }
 688   2          else if(current_interval == 5){
 689   3            // cycle_output[0] = ON;
 690   3            // cycle_output[1] = ON;
 691   3            P36 = 1;
 692   3            P37 = 1;
 693   3          }
 694   2          else if(current_interval == 6){
 695   3            // cycle_output[0] = OFF;
 696   3            // cycle_output[1] = OFF;
 697   3            P36 = 0;
 698   3            P37 = 0;
 699   3          }
 700   2          else if(current_interval == 7){
 701   3            // cycle_output[0] = ON;
 702   3            // cycle_output[1] = ON;
 703   3            P36 = 1;
 704   3            P37 = 1;
 705   3          }
 706   2          else if(current_interval == 8){
 707   3            // cycle_output[0] = OFF;
 708   3            // cycle_output[1] = OFF;
 709   3            P36 = 0;
 710   3            P37 = 0;
 711   3          }
 712   2          else if(current_interval == 9){
 713   3            // cycle_output[0] = ON;
 714   3            // cycle_output[1] = ON;
 715   3            P36 = 1;
 716   3            P37 = 1;
 717   3          }
 718   2          else if(current_interval == 10){
 719   3            // cycle_output[0] = OFF;
 720   3            // cycle_output[1] = OFF;
 721   3            P36 = 0;
 722   3            P37 = 0;
 723   3          }
 724   2          else if(current_interval == 11){
 725   3            // cycle_output[0] = ON;
 726   3            // cycle_output[1] = OFF;
 727   3            P33 = 1;
 728   3          }
 729   2          else if(current_interval == 12){
 730   3            // cycle_output[0] = ON;
 731   3            // cycle_output[1] = OFF;
 732   3            P36 = 1;
 733   3            P37 = 1;
 734   3           P33 = 0;
 735   3          }
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 13  

 736   2          // else if(current_interval == 11){
 737   2          //  // cycle_output[0] = ON;
 738   2          //  // cycle_output[1] = ON;
 739   2          //  P36 = 1;
 740   2          //  P37 = 1;
 741   2          // }
 742   2          reset_counter_for_cycle();
 743   2          ++ current_interval;
 744   2          if(current_interval == 13)
 745   2          // if(current_interval == 12)
 746   2          {
 747   3            current_interval = 0;
 748   3            // cycle_finished = YES;
 749   3          }
 750   2        }
 751   1      }
 752          
 753          // 6
 754          static void
 755          driver_0110_init() {
 756   1        current_interval = 0;
 757   1        cycle_finished = NO;
 758   1        P33 = 0;
 759   1        // cycle_output[0] = ON;
 760   1        // cycle_output[1] = ON;
 761   1        P36 = 1;
 762   1        P37 = 1;
 763   1      }
 764          
 765          
 766          static void 
 767          cycle_reached_0110(u16 cycle) {
 768   1      
 769   1        if(cycle >= cycle_params[current_interval])
 770   1        {
 771   2          if(current_interval == 0){
 772   3            // cycle_output[0] = OFF;
 773   3            // cycle_output[1] = OFF;
 774   3            P36 = 0;
 775   3            P37 = 0;
 776   3          }
 777   2          else if(current_interval == 1){
 778   3            // cycle_output[0] = ON;
 779   3            // cycle_output[1] = OFF;
 780   3            P33 = 1;
 781   3          }
 782   2          else if(current_interval == 2){
 783   3            // cycle_output[0] = ON;
 784   3            // cycle_output[1] = OFF;
 785   3            P36 = 1;
 786   3            P37 = 1;
 787   3           P33 = 0;
 788   3          }
 789   2          // else if(current_interval == 1){
 790   2          //  // cycle_output[0] = ON;
 791   2          //  // cycle_output[1] = ON;
 792   2          //  P36 = 1;
 793   2          //  P37 = 1;
 794   2          // }
 795   2          reset_counter_for_cycle();
 796   2          ++ current_interval;
 797   2          if(current_interval == 3)
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 14  

 798   2          // if(current_interval == 2)
 799   2          {
 800   3            current_interval = 0;
 801   3            // cycle_finished = YES;
 802   3          }
 803   2        }
 804   1      }
 805          
 806          
 807          // 7
 808          static void 
 809          driver_0111_init()
 810          {
 811   1        current_interval = 0;
 812   1        cycle_finished = NO;
 813   1        P33 = 0;
 814   1        // cycle_output[0] = ON;
 815   1        // cycle_output[1] = ON;
 816   1        P36 = 1;
 817   1        P37 = 1;
 818   1      }
 819          
 820          static void
 821          cycle_reached_0111(u16 cycle)
 822          {
 823   1        if(cycle >= cycle_params[current_interval])
 824   1        {
 825   2          if(current_interval == 0){
 826   3            // cycle_output[0] = OFF;
 827   3            // cycle_output[1] = OFF;
 828   3            P36 = 0;
 829   3            P37 = 0;
 830   3          }
 831   2          else if(current_interval == 1){
 832   3            // cycle_output[0] = ON;
 833   3            // cycle_output[1] = ON;
 834   3            P36 = 1;
 835   3            P37 = 1;
 836   3          }
 837   2          else if(current_interval == 2){
 838   3            // cycle_output[0] = OFF;
 839   3            // cycle_output[1] = OFF;
 840   3            P36 = 0;
 841   3            P37 = 0;
 842   3          }
 843   2          else if(current_interval == 3){
 844   3            // cycle_output[0] = ON;
 845   3            // cycle_output[1] = OFF;
 846   3            P33 = 1;
 847   3          }
 848   2          else if(current_interval == 4){
 849   3            // cycle_output[0] = ON;
 850   3            // cycle_output[1] = OFF;
 851   3            P36 = 1;
 852   3            P37 = 1;
 853   3            P33 = 0;
 854   3          }
 855   2          // else if(current_interval == 3){
 856   2          //  // cycle_output[0] = ON;
 857   2          //  // cycle_output[1] = ON;
 858   2          //  P36 = 1;
 859   2          //  P37 = 1;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 15  

 860   2          // }
 861   2          reset_counter_for_cycle();
 862   2          ++ current_interval;
 863   2          if(current_interval == 5)
 864   2          // if(current_interval == 4)
 865   2          {
 866   3            current_interval = 0;
 867   3            // cycle_finished = YES;
 868   3          }
 869   2      
 870   2        }
 871   1      }
 872          
 873          
 874          // 8
 875          static void
 876          driver_1000_init() {
 877   1        current_interval = 0;
 878   1        cycle_finished = NO;
 879   1        P33 = 0;
 880   1        // cycle_output[0] = ON;
 881   1        // cycle_output[1] = OFF;
 882   1        P36 = 1;
 883   1        P37 = 0;
 884   1      }
 885          
 886          
 887          static void 
 888          cycle_reached_1000(u16 cycle) {
 889   1      
 890   1        if(cycle >= cycle_params[current_interval])
 891   1        {
 892   2          if(current_interval == 0){
 893   3            // cycle_output[0] = OFF;
 894   3            // cycle_output[1] = OFF;
 895   3            P36 = 0;
 896   3            P37 = 0;
 897   3          }
 898   2          else if(current_interval == 1){
 899   3            // cycle_output[0] = ON;
 900   3            // cycle_output[1] = OFF;
 901   3            P36 = 1;
 902   3            P37 = 0;
 903   3          }
 904   2          else if(current_interval == 2){
 905   3            // cycle_output[0] = OFF;
 906   3            // cycle_output[1] = OFF;
 907   3            P36 = 0;
 908   3            P37 = 0;
 909   3          }
 910   2          else if(current_interval == 3){
 911   3            // cycle_output[0] = ON;
 912   3            // cycle_output[1] = OFF;
 913   3            P36 = 1;
 914   3            P37 = 0;
 915   3          }
 916   2          else if(current_interval == 4){
 917   3            // cycle_output[0] = OFF;
 918   3            // cycle_output[1] = OFF;
 919   3            P36 = 0;
 920   3            P37 = 0;
 921   3          }
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 16  

 922   2          else if(current_interval == 5){
 923   3            // cycle_output[0] = ON;
 924   3            // cycle_output[1] = OFF;
 925   3            P36 = 1;
 926   3            P37 = 0;    
 927   3          }
 928   2          else if(current_interval == 6){
 929   3            // cycle_output[0] = OFF;
 930   3            // cycle_output[1] = ON;
 931   3            P36 = 0;
 932   3            P37 = 1;
 933   3          }
 934   2          else if(current_interval == 7){
 935   3            // cycle_output[0] = OFF;
 936   3            // cycle_output[1] = OFF;
 937   3            P36 = 0;
 938   3            P37 = 0;
 939   3          }
 940   2          else if(current_interval == 8){
 941   3            // cycle_output[0] = OFF;
 942   3            // cycle_output[1] = ON;
 943   3            P36 = 0;
 944   3            P37 = 1;
 945   3          }
 946   2          else if(current_interval == 9){
 947   3            // cycle_output[0] = OFF;
 948   3            // cycle_output[1] = OFF;
 949   3            P36 = 0;
 950   3            P37 = 0;
 951   3          }
 952   2          else if(current_interval == 10){
 953   3            // cycle_output[0] = ON;
 954   3            // cycle_output[1] = OFF;
 955   3            P36 = 0;
 956   3            P37 = 1;
 957   3          }
 958   2          else if(current_interval == 11){
 959   3            // cycle_output[0] = OFF;
 960   3            // cycle_output[1] = OFF;
 961   3            P36 = 0;
 962   3            P37 = 0;
 963   3          }
 964   2          else if(current_interval == 12){
 965   3            // cycle_output[0] = ON;
 966   3            // cycle_output[1] = OFF;
 967   3            P36 = 0;
 968   3            P37 = 1;
 969   3          }
 970   2          else if(current_interval == 13){
 971   3            // cycle_output[0] = OFF;
 972   3            // cycle_output[1] = OFF;
 973   3            P36 = 0;
 974   3            P37 = 0;
 975   3          }
 976   2          else if(current_interval == 14){
 977   3            // cycle_output[0] = ON;
 978   3            // cycle_output[1] = ON;
 979   3            P36 = 1;
 980   3            P37 = 1;
 981   3          }
 982   2          else if(current_interval == 15){
 983   3            // cycle_output[0] = OFF;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 17  

 984   3            // cycle_output[1] = OFF;
 985   3            P36 = 0;
 986   3            P37 = 0;
 987   3          }
 988   2          else if(current_interval == 16){
 989   3            // cycle_output[0] = ON;
 990   3            // cycle_output[1] = ON;
 991   3            P36 = 1;
 992   3            P37 = 1;
 993   3          }
 994   2          else if(current_interval == 17){
 995   3            // cycle_output[0] = OFF;
 996   3            // cycle_output[1] = OFF;
 997   3            P36 = 0;
 998   3            P37 = 0;
 999   3          }
1000   2          else if(current_interval == 18){
1001   3            // cycle_output[0] = ON;
1002   3            // cycle_output[1] = ON;
1003   3            P36 = 1;
1004   3            P37 = 1;
1005   3          }
1006   2          else if(current_interval == 19){
1007   3            // cycle_output[0] = OFF;
1008   3            // cycle_output[1] = OFF;
1009   3            P36 = 0;
1010   3            P37 = 0;
1011   3          }
1012   2          else if(current_interval == 20){
1013   3            // cycle_output[0] = ON;
1014   3            // cycle_output[1] = ON;
1015   3            P36 = 1;
1016   3            P37 = 1;
1017   3          }
1018   2          else if(current_interval == 21){
1019   3            // cycle_output[0] = OFF;
1020   3            // cycle_output[1] = OFF;
1021   3            P36 = 0;
1022   3            P37 = 0;
1023   3          }
1024   2          else if(current_interval == 22){
1025   3            // cycle_output[0] = ON;
1026   3            // cycle_output[1] = OFF;
1027   3            P33 = 1;
1028   3          }
1029   2          else if(current_interval == 23){
1030   3            // cycle_output[0] = ON;
1031   3            // cycle_output[1] = OFF;
1032   3            P36 = 1;
1033   3            P37 = 0;
1034   3           P33 = 0;
1035   3          }
1036   2          // else if(current_interval == 22){
1037   2          //  // cycle_output[0] = ON;
1038   2          //  // cycle_output[1] = OFF;
1039   2          //  P36 = 1;
1040   2          //  P37 = 0;
1041   2          // }
1042   2          reset_counter_for_cycle();
1043   2          ++ current_interval;
1044   2          if(current_interval == 24)
1045   2          // if(current_interval == 23)
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 18  

1046   2          {
1047   3            current_interval = 0;
1048   3            // cycle_finished = YES;
1049   3          }
1050   2        }
1051   1      }
1052          
1053          
1054          // 9
1055          static void
1056          driver_1001_init() {
1057   1        current_interval = 0;
1058   1        cycle_finished = NO;
1059   1        P33 = 0;
1060   1        // cycle_output[0] = ON;
1061   1        // cycle_output[1] = OFF;
1062   1        P36 = 1;
1063   1        P37 = 0;
1064   1      }
1065          
1066          static void 
1067          cycle_reached_1001(u16 cycle) {
1068   1        if(cycle >= cycle_params[current_interval]){
1069   2          if(current_interval == 0){
1070   3            // cycle_output[0] = OFF;
1071   3            // cycle_output[1] = ON;
1072   3            P36 = 0;
1073   3            P37 = 1;
1074   3          }
1075   2          else if(current_interval == 1){
1076   3            // cycle_output[0] = ON;
1077   3            // cycle_output[1] = OFF;
1078   3            P36 = 1;
1079   3            P37 = 0;
1080   3          }
1081   2          else if(current_interval == 2){
1082   3            // cycle_output[0] = OFF;
1083   3            // cycle_output[1] = OFF;
1084   3            P36 = 0;
1085   3            P37 = 0;
1086   3          }
1087   2          else if(current_interval == 3){
1088   3            // cycle_output[0] = ON;
1089   3            // cycle_output[1] = OFF;
1090   3            P36 = 1;
1091   3            P37 = 0;
1092   3          }
1093   2          else if(current_interval == 4){
1094   3            // cycle_output[0] = OFF;
1095   3            // cycle_output[1] = OFF;
1096   3            P36 = 0;
1097   3            P37 = 0;
1098   3          }
1099   2          else if(current_interval == 5){
1100   3            // cycle_output[0] = ON;
1101   3            // cycle_output[1] = OFF;
1102   3            P36 = 1;
1103   3            P37 = 0;
1104   3          }
1105   2          else if(current_interval == 6){
1106   3            // cycle_output[0] = OFF;
1107   3            // cycle_output[1] = OFF;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 19  

1108   3            P36 = 0;
1109   3            P37 = 0;
1110   3          }
1111   2          else if(current_interval == 7){
1112   3            // cycle_output[0] = ON;
1113   3            // cycle_output[1] = OFF;
1114   3            P36 = 1;
1115   3            P37 = 0;
1116   3          }
1117   2          else if(current_interval == 8){
1118   3            // cycle_output[0] = OFF;
1119   3            // cycle_output[1] = ON;
1120   3            P36 = 0;
1121   3            P37 = 1;
1122   3          }
1123   2          else if(current_interval == 9){
1124   3            // cycle_output[0] = OFF;
1125   3            // cycle_output[1] = OFF;
1126   3            P36 = 0;
1127   3            P37 = 0;
1128   3          }
1129   2          else if(current_interval == 10){
1130   3            // cycle_output[0] = OFF;
1131   3            // cycle_output[1] = ON;
1132   3            P36 = 0;
1133   3            P37 = 1;
1134   3          }
1135   2          else if(current_interval == 11){
1136   3            // cycle_output[0] = OFF;
1137   3            // cycle_output[1] = OFF;
1138   3            P36 = 0;
1139   3            P37 = 0;
1140   3          }
1141   2          else if(current_interval == 12){
1142   3            // cycle_output[0] = OFF;
1143   3            // cycle_output[1] = ON;
1144   3            P36 = 0;
1145   3            P37 = 1;
1146   3          }
1147   2          else if(current_interval == 13){
1148   3            // cycle_output[0] = OFF;
1149   3            // cycle_output[1] = OFF;
1150   3            P36 = 0;
1151   3            P37 = 0;
1152   3          }
1153   2          else if(current_interval == 14){
1154   3            // cycle_output[0] = OFF;
1155   3            // cycle_output[1] = ON;
1156   3            P36 = 0;
1157   3            P37 = 1;
1158   3          }
1159   2          else if(current_interval == 15){
1160   3            // cycle_output[0] = OFF;
1161   3            // cycle_output[1] = OFF;
1162   3            P36 = 0;
1163   3            P37 = 0;
1164   3          }
1165   2          else if(current_interval == 16){
1166   3            // cycle_output[0] = ON;
1167   3            // cycle_output[1] = ON;
1168   3            P36 = 1;
1169   3            P37 = 1;
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 20  

1170   3          }
1171   2          else if(current_interval == 17){
1172   3            // cycle_output[0] = OFF;
1173   3            // cycle_output[1] = OFF;
1174   3            P36 = 0;
1175   3            P37 = 0;
1176   3          }
1177   2          else if(current_interval == 18){
1178   3            // cycle_output[0] = ON;
1179   3            // cycle_output[1] = ON;
1180   3            P36 = 1;
1181   3            P37 = 1;
1182   3          }
1183   2          else if(current_interval == 19){
1184   3            // cycle_output[0] = OFF;
1185   3            // cycle_output[1] = OFF;
1186   3            P36 = 0;
1187   3            P37 = 0;
1188   3          }
1189   2          else if(current_interval == 20){
1190   3            // cycle_output[0] = ON;
1191   3            // cycle_output[1] = ON;
1192   3            P36 = 1;
1193   3            P37 = 1;
1194   3          }
1195   2          else if(current_interval == 21){
1196   3            // cycle_output[0] = OFF;
1197   3            // cycle_output[1] = OFF;
1198   3            P36 = 0;
1199   3            P37 = 0;
1200   3          }
1201   2          else if(current_interval == 22){
1202   3            // cycle_output[0] = ON;
1203   3            // cycle_output[1] = ON;
1204   3            P36 = 1;
1205   3            P37 = 1;
1206   3          }
1207   2          else if(current_interval == 23){
1208   3            // cycle_output[0] = OFF;
1209   3            // cycle_output[1] = OFF;
1210   3            P36 = 0;
1211   3            P37 = 0;
1212   3          }
1213   2          else if(current_interval == 24){
1214   3            // cycle_output[0] = ON;
1215   3            // cycle_output[1] = OFF;
1216   3            P33 = 1;
1217   3          }
1218   2          else if(current_interval == 25){
1219   3            // cycle_output[0] = ON;
1220   3            // cycle_output[1] = OFF;
1221   3            P36 = 1;
1222   3            P37 = 0;
1223   3           P33 = 0;
1224   3          }
1225   2          // else if(current_interval == 24){
1226   2          //  // cycle_output[0] = ON;
1227   2          //  // cycle_output[1] = OFF;
1228   2          //  P36 = 1;
1229   2          //  P37 = 0;
1230   2          // }
1231   2          reset_counter_for_cycle();
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 21  

1232   2          ++ current_interval;
1233   2          if(current_interval == 26)
1234   2          // if(current_interval == 25)
1235   2          {
1236   3            current_interval = 0;
1237   3            // cycle_finished = YES;
1238   3          }
1239   2        }
1240   1      }
1241          
1242          
1243          // 10
1244          static void
1245          driver_1010_init() {
1246   1        current_interval = 0;
1247   1        cycle_finished = NO;
1248   1        P33 = 0;
1249   1        // cycle_output[0] = ON;
1250   1        // cycle_output[1] = ON;
1251   1            P36 = 1;
1252   1            P37 = 1;
1253   1      }
1254          
1255          static void 
1256          cycle_reached_1010(u16 cycle) {
1257   1        if(cycle >= cycle_params[current_interval]){
1258   2          if(current_interval == 0){
1259   3            // cycle_output[0] = OFF;
1260   3            // cycle_output[1] = OFF;
1261   3            P36 = 0;
1262   3            P37 = 0;
1263   3          }
1264   2          else if(current_interval == 1){
1265   3            // cycle_output[0] = ON;
1266   3            // cycle_output[1] = ON;
1267   3            P36 = 1;
1268   3            P37 = 1;
1269   3          }
1270   2          else if(current_interval == 2){
1271   3            // cycle_output[0] = OFF;
1272   3            // cycle_output[1] = OFF;
1273   3            P36 = 0;
1274   3            P37 = 0;
1275   3          }
1276   2          else if(current_interval == 3){
1277   3            // cycle_output[0] = ON;
1278   3            // cycle_output[1] = ON;
1279   3            P36 = 1;
1280   3            P37 = 1;
1281   3          }
1282   2          else if(current_interval == 4){
1283   3            // cycle_output[0] = OFF;
1284   3            // cycle_output[1] = OFF;
1285   3            P36 = 0;
1286   3            P37 = 0;
1287   3          }
1288   2          else if(current_interval == 5){
1289   3            // cycle_output[0] = ON;
1290   3            // cycle_output[1] = ON;
1291   3            P36 = 1;
1292   3            P37 = 1;
1293   3          }
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 22  

1294   2          else if(current_interval == 6){
1295   3            // cycle_output[0] = OFF;
1296   3            // cycle_output[1] = OFF;
1297   3            P36 = 0;
1298   3            P37 = 0;
1299   3          }
1300   2          else if(current_interval == 7){
1301   3            // cycle_output[0] = ON;
1302   3            // cycle_output[1] = ON;
1303   3            P36 = 1;
1304   3            P37 = 1;
1305   3          }
1306   2          else if(current_interval == 8){
1307   3            // cycle_output[0] = OFF;
1308   3            // cycle_output[1] = OFF;
1309   3            P36 = 0;
1310   3            P37 = 0;
1311   3          }
1312   2          else if(current_interval == 9){
1313   3            // cycle_output[0] = ON;
1314   3            // cycle_output[1] = ON;
1315   3            P36 = 1;
1316   3            P37 = 1;
1317   3          }
1318   2          else if(current_interval == 10){
1319   3            // cycle_output[0] = OFF;
1320   3            // cycle_output[1] = OFF;
1321   3            P36 = 0;
1322   3            P37 = 0;
1323   3          }
1324   2          else if(current_interval == 11){
1325   3            // cycle_output[0] = ON;
1326   3            // cycle_output[1] = OFF;
1327   3            P33 = 1;
1328   3          }
1329   2          else if(current_interval == 12){
1330   3            // cycle_output[0] = ON;
1331   3            // cycle_output[1] = ON;
1332   3            P36 = 1;
1333   3            P37 = 1;
1334   3           P33 = 0;
1335   3          }
1336   2          // else if(current_interval == 11){
1337   2          //  // cycle_output[0] = ON;
1338   2          //  // cycle_output[1] = ON;
1339   2          //  P36 = 1;
1340   2          //  P37 = 1;
1341   2          // }
1342   2          reset_counter_for_cycle();
1343   2          ++ current_interval;
1344   2          if(current_interval == 13)
1345   2          // if(current_interval == 12)
1346   2          {
1347   3            current_interval = 0;
1348   3            // cycle_finished = YES;
1349   3          }
1350   2        }
1351   1      }
1352          
1353          // 11
1354          static void
1355          driver_1011_init() {
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 23  

1356   1        current_interval = 0;
1357   1        cycle_finished = NO;
1358   1        P33 = 0;
1359   1        // cycle_output[0] = ON;
1360   1        // cycle_output[1] = ON;
1361   1        P36 = 1;
1362   1        P37 = 1;
1363   1      }
1364          
1365          static void 
1366          cycle_reached_1011(u16 cycle)
1367          {
1368   1        if(cycle >= cycle_params[current_interval]){  
1369   2          if(current_interval == 0){
1370   3            // cycle_output[0] = OFF;
1371   3            // cycle_output[1] = OFF;
1372   3            P36 = 0;
1373   3            P37 = 0;
1374   3          }
1375   2          else if(current_interval == 1){
1376   3            // cycle_output[0] = ON;
1377   3            // cycle_output[1] = OFF;
1378   3            P33 = 1;
1379   3          }
1380   2          else if(current_interval == 2){
1381   3            // cycle_output[0] = ON;
1382   3            // cycle_output[1] = OFF;
1383   3            P36 = 1;
1384   3            P37 = 1;
1385   3           P33 = 0;
1386   3          }
1387   2          // else if(current_interval == 1){
1388   2          //  // cycle_output[0] = ON;
1389   2          //  // cycle_output[1] = ON;
1390   2          //  P36 = 1;
1391   2          //  P37 = 1;
1392   2          // }
1393   2          reset_counter_for_cycle();
1394   2          ++ current_interval;
1395   2          if(current_interval == 3)
1396   2          // if(current_interval == 2)
1397   2          {
1398   3            current_interval = 0;
1399   3            // cycle_finished = YES;
1400   3          }
1401   2        
1402   2        }
1403   1      }
1404          
1405          // 12
1406          static void
1407          driver_1100_init() {
1408   1        current_interval = 0;
1409   1        cycle_finished = NO;
1410   1        P33 = 0;
1411   1        // cycle_output[0] = ON;
1412   1        // cycle_output[1] = ON;
1413   1        P36 = 1;
1414   1        P37 = 1;
1415   1      }
1416          
1417          static void 
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 24  

1418          cycle_reached_1100(u16 cycle) {
1419   1        if(cycle >= cycle_params[current_interval]){
1420   2          if(current_interval == 0){
1421   3            // cycle_output[0] = OFF;
1422   3            // cycle_output[1] = OFF;
1423   3            P36 = 0;
1424   3            P37 = 0;
1425   3          }
1426   2          else if(current_interval == 1){
1427   3            // cycle_output[0] = ON;
1428   3            // cycle_output[1] = ON;
1429   3            P36 = 1;
1430   3            P37 = 1;
1431   3          }
1432   2          else if(current_interval == 2){
1433   3            // cycle_output[0] = OFF;
1434   3            // cycle_output[1] = OFF;
1435   3            P36 = 0;
1436   3            P37 = 0;
1437   3          }
1438   2          else if(current_interval == 3){
1439   3            // cycle_output[0] = ON;
1440   3            // cycle_output[1] = OFF;
1441   3            P33 = 1;
1442   3          }
1443   2          else if(current_interval == 4){
1444   3            // cycle_output[0] = ON;
1445   3            // cycle_output[1] = OFF;
1446   3            P36 = 1;
1447   3            P37 = 1;
1448   3           P33 = 0;
1449   3          }
1450   2          // else if(current_interval == 3){
1451   2          //  // cycle_output[0] = ON;
1452   2          //  // cycle_output[1] = ON;
1453   2          //  P36 = 1;
1454   2          //  P37 = 1;
1455   2          // }
1456   2          reset_counter_for_cycle();
1457   2          ++ current_interval;
1458   2          if(current_interval == 5)
1459   2          // if(current_interval == 4)
1460   2          {
1461   3            current_interval = 0;
1462   3            // cycle_finished = YES;
1463   3          }
1464   2        }
1465   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1985    ----
   CONSTANT SIZE    =    248    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      5    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
C51 COMPILER V9.52.0.0   DISPLAY                                                           01/12/2016 10:47:30 PAGE 25  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
