C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN display.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE display.c COMPACT OMF2 OPTIMIZE(9,SPEED) BROWSE DEBUG TABS(2)

line level    source

   1          #include "shared.h"
   2          #include "display.h"
   3          #include "sync.h"
   4          #include "def.h"
   5          #include "intrins.h"
   6          #include "adc.h"
   7          #include "uart.h"
   8          // ------------------------- display config declaring -------------------------
   9          static code disp_t const
  10          next_display_mode[12] = {sequential, slow_glo, chasing_flash, slow_fade, twinkle_flash, stacking_flash,
  11            flash_and_chase, random_flashing, pulsing, sequential_flashing, bi_directional_storbing, in_wave};
  12          
  13          // combination start from second disp_t
  14          #define next_display_mode_from  1
  15          
  16          // TODO 60Hz is ok, 50Hz is not
  17          static code u16 const
  18          phase_delay_for_60Hz[10] = {0x2666, 0x2533, 0x2280, 0x201A, 0x1CB3, 0x1B26, 0x18C0, 0x1633, 0x13CD, 0x0F00
             -};
  19          // Cycle are calculated based on 5ms PCA timer -> sync.h
  20          // 2
  21          static code u16 const 
  22          cycle_for_in_wave[4][11]= {
  23            // 最后一位是半个周期的长度
  24            {10, 5, 5, 5, 5, 10, 5, 5, 5, 5, 30},
  25            {30, 15, 15, 15, 15, 30, 15, 15, 15, 15, 90},
  26            {20, 10, 10, 10, 10, 20, 10, 10, 10, 10, 60},
  27            {40, 20, 20, 20, 20, 40, 20, 20, 20, 20, 120}
  28          };
  29          // 3
  30          static code u16 const 
  31          cycle_for_sequential[5][6] = {
  32            {100, 50, 50, 50, 50, 100},
  33            {80, 40, 40, 40, 40, 80},
  34            {60, 30, 30, 30, 30, 60},
  35            {40, 20, 20, 20, 20, 40},
  36            {20, 10, 10, 10, 10, 20}
  37          };
  38          static u8 cycle_counter_for_sequential_per_interval[5] = {2,4,6,8,10};
  39          static u8 sequential_cycle_counter = 0;
  40          // 4
  41          static code u16 const 
  42          cycle_for_slow_glo[4][11] = {
  43            {1200, 400, 400, 400, 400, 400, 400, 400, 400, 1200, 400},
  44            {600, 200, 200, 200, 200, 200, 200, 200, 200, 600, 200},
  45            {300, 100, 100, 100, 100, 100, 100, 100, 100, 300, 200},
  46            {150, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50}
  47          };
  48          // 5
  49          static code u16 const 
  50          cycle_for_chasing_flash[4][16] = {
  51            {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20},
  52            {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20},
  53            {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20},
  54            {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20}
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 2   

  55          };
  56          static u8 cycle_counter_for_chasing_flash_per_interval[4] = {4,1,4,1};
  57          static u8 chasing_flash_cycle_counter = 0;
  58          // 6
  59          static code u16 const 
  60          cycle_for_slow_fade[16] = {1600, 1600, 1600, 1600, 800, 800, 800, 800, 500, 500, 500, 500, 400, 400, 400, 
             -400};
  61          // 7
  62          static code u16 const 
  63          cycle_for_twinkle_flash[16] = {20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20};
  64          
  65          
  66          // 8
  67          static code u16 const 
  68          cycle_for_stacking_flash[11] = {67, 60, 53, 46, 39, 100, 28, 22, 16, 11, 5};
  69          // 9
  70          static code u16 const 
  71          cycle_for_flash_and_chase[11] = {67, 60, 53, 46, 39, 100, 28, 22, 16, 11, 5};
  72          // 10
  73          static code u16 const 
  74          cycle_for_random_flashing[11] = {67, 60, 53, 46, 39, 100, 28, 22, 16, 11, 5};
  75          
  76          // 11
  77          static code u16 const 
  78          cycle_for_pulsing[11] = {367, 333, 300, 267, 233, 200, 167, 133, 100, 67, 33};
  79          // 12
  80          static code u16 const 
  81          cycle_for_sequential_flashing[11] = {67, 60, 53, 46, 39, 100, 28, 22, 16, 11, 5};
  82          
  83          // 13
  84          static code u16 const
  85          cycle_for_bi_directional_storbing[11] = {51, 47, 42, 37, 33, 27, 23, 19, 14, 9, 5};
  86          
  87          // 14
  88          static code u16 const 
  89          cycle_for_sensor[12] = {200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200};
  90          
  91          #define cycle_for_not_effective_default NULL
  92          
  93          #define BASE_AVG 0x50
  94          // Sensor mode calculation based
  95          // Lumins level 3 - 10
  96          static code u8 const 
  97          diff_avg_range_1[8] = {1, 2, 3, 4, 5, 6, 7, 8};
  98          static code u8 const   
  99          diff_avg_range_2[8] = {1, 3, 5, 8, 10, 11, 13, 14};
 100          static code u8 const   
 101          diff_avg_range_3[8] = {4, 7, 11, 15, 20, 26, 31, 35};
 102          static code u8 const   
 103          diff_avg_range_4[8] = {4, 7, 11, 15, 18, 24, 28, 31};
 104          
 105          // Lumins level 2 for max_of_period_max < max_avg
 106          #define below_avg_threshhold_for_peace    8
 107          // Lumins level 1 for each range
 108          static code u8 const   
 109          below_avg_threshold[4] = {9, 10, 11, 12};
 110          static code u8 const   
 111          avg_range[4] = {0x00, 0x20, 0x25, 0x28};
 112          
 113          // ------------------------- display private params -------------------------
 114          // idata *cycle_param -> cycle_for_detailed_display_mode in code
 115          static const u16 code * data cycle_params;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 3   

 116          // point to  , self can be modify
 117          static const u16 code * data current_phase_delay;
 118          // idata *display_driver -> detailed display_driver
 119          static display_driver_pt display_driver;
 120          static cycle_reached_pt cycle_reached;
 121          // lumins_level need to be fine-grained
 122          static BOOL lumins_level_fine_override = NO; 
 123          // deviation based on lower lumins_level_t in both RISE | FALL phase
 124          //static u8 lumins_level_deviation = 0;
 125          static u8 lumins_level_deviation[3] = {0};
 126          // mode 完成次数
 127          static u8 counter_for_current_cycle = 0;
 128          static u8 counter_for_minute = 6;
 129          
 130          
 131          #define fade_in_out_fine_grained_level 10
 132          //static bit fade_in_out_flag = RISE;
 133          static u8 fade_in_out_flag[3] = {RISE, RISE, RISE};
 134          static bit dim_in_out_flag = FULL;
 135          #define lumins_level_min_deviation_interval_for_60Hz  120
 136          static u8 current_interval = 0;
 137          static u8 slow_glo_counter = 0;
 138          static u8 in_wave_counter = 0;
 139          static const u8 code * data diff;
 140          
 141          #define AVG_BUFFER_SIZE_BIT 4
 142          #define AVG_BUFFER_SIZE   (1 << AVG_BUFFER_SIZE_BIT)
 143          #define PERIOD_MAX_SIZE   4
 144          static xdata u16 avg_buffer[AVG_BUFFER_SIZE];
 145          static u16 period_max_buffer[PERIOD_MAX_SIZE];
 146          static u16 current_adc_max, max_sum = BASE_AVG << AVG_BUFFER_SIZE_BIT, max_avg = BASE_AVG;
 147          static u8 max_avg_index = 0, period_max_index = 0;
 148          static toggle_t toggle_stat_last_for_sensor_prevent_inst_blink = ON;
 149          static BOOL sensor_initializing = NO;
 150          
 151          u8 sensor_counter = 1; 
 152          
 153          // ------------------------- marco functions -------------------------
 154          
 155          #define reverse_dim_in_out_flag() dim_in_out_flag = ~dim_in_out_flag 
 156          #define sync_up_toggle_stat() toggle_stat_last_for_sensor_prevent_inst_blink = toggle_status
 157          #define index_of(x) x - 1
 158          //#define set_phase_timer(x) TL0 = x; TH0 = x >> 8
 159          #define lumins_level_fine_override_should_change(target) lumins_level_fine_override = (target == steady_on
             - || target == sensor || target == bi_directional_storbing || target == stacking_flash || target == random_flashing || ta
             -rget == pulsing || target == sequential_flashing) ? NO : YES
 160          #define sensor_should_reinit_from_awake() ( toggle_status == ON && toggle_stat_last_for_sensor_prevent_ins
             -t_blink == OFF)
 161          #define sensor_initializing_finished()  (max_avg_index == (AVG_BUFFER_SIZE >> 2))
 162          // ------------------------- private declaring -------------------------
 163          //static void half_cycle_reached();
 164          static u16 recalibrate_phase_delay(lumins_level_t lumins,   u8 deviation);
 165          static u16 find_period_max_in_buffer();
 166          
 167          // ------------------------- display_mode_init declaring -------------------------
 168          static void combination_driver_init();
 169          static void in_wave_driver_init();
 170          static void sequential_driver_init();
 171          static void slow_glo_driver_init();
 172          static void chasing_flash_driver_init();
 173          static void slow_fade_driver_init();
 174          static void twinkle_flash_driver_init();
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 4   

 175          static void stacking_flash_driver_init();
 176          static void flash_and_chase_driver_init();
 177          static void random_flashing_driver_init();
 178          static void pulsing_driver_init();
 179          static void sequential_flashing_driver_init();
 180          static void bi_directional_storbing_driver_init();
 181          static void steady_on_driver_init();
 182          static void sensor_driver_init();
 183          
 184          // ------------------------- display_mode_driver declaring -------------------------
 185          //static void combination_driver();
 186          static void in_wave_driver();
 187          static void sequential_driver();
 188          static void slow_glo_driver();
 189          static void chasing_flash_driver();
 190          static void slow_fade_driver();
 191          static void twinkle_flash_driver();
 192          static void stacking_flash_driver();
 193          static void flash_and_chase_driver();
 194          static void random_flashing_driver();
 195          static void pulsing_driver();
 196          static void sequential_flashing_driver();
 197          static void bi_directional_storbing_driver();
 198          static void steady_on_driver();
 199          static void sensor_driver();
 200          
 201          // ------------------------- display_mode_cycle_reached declaring -------------------------
 202          static void cycle_reached_in_wave(u16);
 203          static void cycle_reached_sequential(u16);
 204          static void cycle_reached_slow_glo(u16);
 205          static void cycle_reached_chasing_flash(u16);
 206          static void cycle_reached_slow_fade(u16);
 207          static void cycle_reached_twinkle_flash(u16);
 208          static void cycle_reached_stacking_flash(u16);
 209          static void cycle_reached_flash_and_chase(u16);
 210          static void cycle_reached_random_flashing(u16);
 211          static void cycle_reached_pulsing(u16);
 212          static void cycle_reached_sequential_flashing(u16);
 213          static void cycle_reached_bi_directional_storbing(u16);
 214          //static void cycle_reached_steady_burn(u16);
 215          // static void cycle_reached_sensor(u16);
 216          
 217          
 218          // ------------------------- public -------------------------
 219          // ONLY CALL BY main_isr
 220          // CAUTIONS!  DON't CALL THIS
 221          void display_startup_init() {
 222   1        _nop_();              // 1. no need to call steady_driver_init
 223   1        display_driver = steady_on_driver;  // 2. dispatch display_driver
 224   1        cycle_params = cycle_for_not_effective_default; // 3. dispatch cycle_params
 225   1      //  cycle_reached = cycle_reached_chasing_flash;
 226   1        _nop_();              // 4. lumins_level_fine_override set by default to NO
 227   1        _nop_();              // 5. counters are init by sync.c
 228   1        current_phase_delay = phase_delay_for_60Hz; // 6. reset current phase_delay
 229   1      //  display_mode_set_changed();
 230   1        sensor_driver_init();
 231   1      }
 232          
 233          void
 234          prepare_next_display_params() {
 235   1        if(!P12)
 236   1        {
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 5   

 237   2          adc_should_sampling = NO;
 238   2          display_driver();
 239   2        }
 240   1        else
 241   1        {
 242   2          adc_should_sampling = YES;
 243   2          sensor_driver();
 244   2        }
 245   1        // preserve toggle_status for next round
 246   1        sync_up_toggle_stat();
 247   1      }
 248          
 249          void
 250          ctrl_toggle_status_response(const toggle_t prev) {
 251   1        if (toggle_status != prev) {
 252   2          _nop_();
 253   2        }
 254   1      }
 255          
 256          void
 257          ctrl_display_mode_response(const disp_t prev) {
 258   1        if (display_mode_set != prev) {
 259   2          adc_disable();
 260   2          display_mode_set_changed();
 261   2        }
 262   1      }
 263          
 264          void
 265          toggle_once() {
 266   1        lumins_level_t lumins[3];
 267   1        u16 current_counter;
 268   1        lumins_level_logic[0] = lumins_level_logic_prepared[0];
 269   1        lumins_level_logic[1] = lumins_level_logic_prepared[1];
 270   1        lumins_level_logic[2] = lumins_level_logic_prepared[2];
 271   1        lumins[0] = lumins_level_logic[0];
 272   1        lumins[1] = lumins_level_logic[1];
 273   1        lumins[2] = lumins_level_logic[2];
 274   1        calibrated_phase_delay[0] = 0;
 275   1        calibrated_phase_delay[1] = 0;
 276   1        calibrated_phase_delay[2] = 0;  
 277   1        if (lumins[0] && cycle_output[0])
 278   1          calibrated_phase_delay[0] = current_phase_delay[lumins[0] - 1];
 279   1        if (lumins[1] && cycle_output[1])
 280   1          calibrated_phase_delay[1] = current_phase_delay[lumins[1] - 1];
 281   1        if (lumins[2] && cycle_output[2])
 282   1          calibrated_phase_delay[2] = current_phase_delay[lumins[2] - 1];
 283   1        current_counter =  (CH << 8) | CL;
 284   1      
 285   1        if (!lumins_level_fine_override || (lumins_level_fine_override && P12)) {
 286   2          
 287   2          CCPA_tmp[0] = current_counter + calibrated_phase_delay[0];
 288   2              CCAP0L = CCPA_tmp[0] ;
 289   2              CCAP0H = CCPA_tmp[0] >> 8;
 290   2          CCPA_tmp[1] = current_counter + calibrated_phase_delay[1];
 291   2              CCAP1L = CCPA_tmp[1] ;
 292   2              CCAP1H = CCPA_tmp[1] >> 8;
 293   2              CCPA_tmp[2] = current_counter + calibrated_phase_delay[2];
 294   2              CCAP2L = CCPA_tmp[2] ;
 295   2              CCAP2H = CCPA_tmp[2] >> 8;
 296   2      
 297   2        } 
 298   1        else 
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 6   

 299   1        { 
 300   2          if(cycle_output[0])
 301   2            calibrated_phase_delay[0] = recalibrate_phase_delay(lumins[0], lumins_level_deviation[0]);
 302   2          else
 303   2            calibrated_phase_delay[0] = 0;
 304   2          if(cycle_output[1])
 305   2                calibrated_phase_delay[1] = recalibrate_phase_delay(lumins[1], lumins_level_deviation[1]);
 306   2          else
 307   2            calibrated_phase_delay[1] = 0;
 308   2          if(cycle_output[2])
 309   2                calibrated_phase_delay[2] = recalibrate_phase_delay(lumins[2], lumins_level_deviation[2]);
 310   2          else
 311   2            calibrated_phase_delay[2] = 0;
 312   2      
 313   2          CCPA_tmp[0] = current_counter + calibrated_phase_delay[0];
 314   2            CCAP0L = CCPA_tmp[0] ;
 315   2            CCAP0H = CCPA_tmp[0] >> 8;
 316   2              
 317   2          CCPA_tmp[1] = current_counter + calibrated_phase_delay[1];
 318   2            CCAP1L = CCPA_tmp[1] ;
 319   2            CCAP1H = CCPA_tmp[1] >> 8;
 320   2          
 321   2          CCPA_tmp[2] = current_counter + calibrated_phase_delay[2];
 322   2            CCAP2L = CCPA_tmp[2] ;
 323   2            CCAP2H = CCPA_tmp[2] >> 8;
 324   2      
 325   2        }
 326   1        phase_ctrl_enable();
 327   1      }
 328          
 329          void 
 330          cycle_based_adjust(const u16 cycle) {
 331   1        if(display_mode_set == steady_on)
 332   1        {
 333   2          reset_counter_for_cycle();
 334   2        }
 335   1        else
 336   1        {
 337   2          cycle_reached(cycle);
 338   2        }
 339   1      
 340   1      }
 341          
 342          void 
 343          display_mode_set_changed() {
 344   1        // DON't trig display_mode_logic_changed()
 345   1        // -> sync.h
 346   1        cycle_ctrl_disable();
 347   1        display_mode_logic = display_mode_set;
 348   1        // 1. driver init
 349   1        // 2. display_driver -> detailed
 350   1        // 3. cycle_params -> detailed
 351   1        switch (display_mode_set) {
 352   2          case combination:
 353   2            combination_driver_init();
 354   2            // display_mode_logic will never be combination
 355   2            // don't set display driver -> combination driver
 356   2            // don't set cycle_params -> any
 357   2            break;
 358   2          case in_wave: 
 359   2            in_wave_driver_init();
 360   2            display_driver = in_wave_driver;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 7   

 361   2            cycle_params = cycle_for_in_wave[0];
 362   2            cycle_reached = cycle_reached_in_wave;
 363   2            break;
 364   2          case sequential: 
 365   2            sequential_driver_init();
 366   2            display_driver = sequential_driver;
 367   2            cycle_params = cycle_for_sequential[0];
 368   2            cycle_reached = cycle_reached_sequential;
 369   2            break;
 370   2          case slow_glo: 
 371   2            slow_glo_driver_init();
 372   2            display_driver = slow_glo_driver;
 373   2            cycle_params = cycle_for_slow_glo[0];
 374   2            cycle_reached = cycle_reached_slow_glo;
 375   2            break;
 376   2          case chasing_flash: 
 377   2            chasing_flash_driver_init();
 378   2            display_driver = chasing_flash_driver;
 379   2            cycle_params = cycle_for_chasing_flash[0];
 380   2            cycle_reached = cycle_reached_chasing_flash;
 381   2            break;
 382   2          case slow_fade: 
 383   2            slow_fade_driver_init();
 384   2            display_driver = slow_fade_driver;
 385   2            cycle_params = cycle_for_slow_fade;
 386   2            cycle_reached = cycle_reached_slow_fade;
 387   2            break;
 388   2          case twinkle_flash: 
 389   2            twinkle_flash_driver_init();
 390   2            display_driver = twinkle_flash_driver;
 391   2            cycle_params = cycle_for_twinkle_flash;
 392   2            cycle_reached = cycle_reached_twinkle_flash;
 393   2            break;
 394   2          case stacking_flash: 
 395   2            stacking_flash_driver_init();
 396   2            display_driver = stacking_flash_driver;
 397   2            cycle_params = cycle_for_stacking_flash;
 398   2            cycle_reached = cycle_reached_stacking_flash;
 399   2            break;
 400   2          case flash_and_chase: 
 401   2            flash_and_chase_driver_init();
 402   2            display_driver = flash_and_chase_driver;
 403   2            cycle_params = cycle_for_flash_and_chase;
 404   2            cycle_reached = cycle_reached_flash_and_chase;
 405   2            break;
 406   2          case random_flashing: 
 407   2            random_flashing_driver_init();
 408   2            display_driver = random_flashing_driver;
 409   2            cycle_params = cycle_for_random_flashing;
 410   2            cycle_reached = cycle_reached_random_flashing;
 411   2            break;
 412   2          case pulsing: 
 413   2            pulsing_driver_init();
 414   2            display_driver = pulsing_driver;
 415   2            cycle_params = cycle_for_pulsing;
 416   2            cycle_reached = cycle_reached_pulsing;
 417   2            break;
 418   2          case sequential_flashing: 
 419   2            sequential_flashing_driver_init();
 420   2            display_driver = sequential_flashing_driver;
 421   2            cycle_params = cycle_for_sequential_flashing;
 422   2            cycle_reached = cycle_reached_sequential_flashing;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 8   

 423   2            break;
 424   2          case bi_directional_storbing: 
 425   2            bi_directional_storbing_driver_init();
 426   2            display_driver = bi_directional_storbing_driver;
 427   2            cycle_params = cycle_for_bi_directional_storbing;
 428   2            cycle_reached = cycle_reached_bi_directional_storbing;
 429   2            break;
 430   2          case steady_on: 
 431   2            steady_on_driver_init();
 432   2            display_driver = steady_on_driver;
 433   2            cycle_params = cycle_for_not_effective_default;
 434   2            break;    
 435   2          case sensor:
 436   2            // sensor_driver_init();
 437   2            // display_driver = sensor_driver;
 438   2            // cycle_params = cycle_for_sensor;
 439   2            // cycle_reached = cycle_reached_sensor;
 440   2            break;
 441   2          default:
 442   2            break; 
 443   2        }
 444   1      
 445   1        // override flag -> YES:  (slow)fade-in-out
 446   1        // override flag -> NO:   else
 447   1        lumins_level_fine_override_should_change(display_mode_logic);
 448   1        reset_all_counters();
 449   1        // -> sync.h
 450   1        cycle_ctrl_enable();
 451   1      }
 452          
 453          // called by pca_isr (combination rotation)
 454          // called by com_isr (combination init)
 455          void 
 456          display_mode_logic_changed() {
 457   1        // 1. driver init
 458   1        // 2. display_driver -> detailed
 459   1        // 3. cycle_params -> detailed
 460   1        // -> sync.h
 461   1        //cycle_ctrl_disable();
 462   1        switch (display_mode_logic) {
 463   2      
 464   2          case combination:
 465   2            // display_mode_logic will never be combination
 466   2            break;
 467   2          case in_wave: 
 468   2            in_wave_driver_init();
 469   2            display_driver = in_wave_driver;
 470   2            cycle_params = cycle_for_in_wave[0];
 471   2            cycle_reached = cycle_reached_in_wave;
 472   2            break;
 473   2          case sequential: 
 474   2            sequential_driver_init();
 475   2            display_driver = sequential_driver;
 476   2            cycle_params = cycle_for_sequential[0];
 477   2            cycle_reached = cycle_reached_sequential;
 478   2            break;
 479   2          case slow_glo: 
 480   2            slow_glo_driver_init();
 481   2            display_driver = slow_glo_driver;
 482   2            cycle_params = cycle_for_slow_glo[0];
 483   2            cycle_reached = cycle_reached_slow_glo;
 484   2            break;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 9   

 485   2          case chasing_flash: 
 486   2            chasing_flash_driver_init();
 487   2            display_driver = chasing_flash_driver;
 488   2            cycle_params = cycle_for_chasing_flash[0];
 489   2            cycle_reached = cycle_reached_chasing_flash;
 490   2            break;
 491   2          case slow_fade: 
 492   2            slow_fade_driver_init();
 493   2            display_driver = slow_fade_driver;
 494   2            cycle_params = cycle_for_slow_fade;
 495   2            cycle_reached = cycle_reached_slow_fade;
 496   2            break;
 497   2          case twinkle_flash: 
 498   2            twinkle_flash_driver_init();
 499   2            display_driver = twinkle_flash_driver;
 500   2            cycle_params = cycle_for_twinkle_flash;
 501   2            cycle_reached = cycle_reached_twinkle_flash;
 502   2            break;
 503   2          case stacking_flash: 
 504   2            stacking_flash_driver_init();
 505   2            display_driver = stacking_flash_driver;
 506   2            cycle_params = cycle_for_stacking_flash;
 507   2            cycle_reached = cycle_reached_stacking_flash;
 508   2            break;
 509   2          case flash_and_chase: 
 510   2            flash_and_chase_driver_init();
 511   2            display_driver = flash_and_chase_driver;
 512   2            cycle_params = cycle_for_flash_and_chase;
 513   2            cycle_reached = cycle_reached_flash_and_chase;
 514   2            break;
 515   2          case random_flashing: 
 516   2            random_flashing_driver_init();
 517   2            display_driver = random_flashing_driver;
 518   2            cycle_params = cycle_for_random_flashing;
 519   2            cycle_reached = cycle_reached_random_flashing;
 520   2            break;
 521   2          case pulsing: 
 522   2            pulsing_driver_init();
 523   2            display_driver = pulsing_driver;
 524   2            cycle_params = cycle_for_pulsing;
 525   2            cycle_reached = cycle_reached_pulsing;
 526   2            break;
 527   2          case sequential_flashing: 
 528   2            sequential_flashing_driver_init();
 529   2            display_driver = sequential_flashing_driver;
 530   2            cycle_params = cycle_for_sequential_flashing;
 531   2            cycle_reached = cycle_reached_sequential_flashing;
 532   2            break;
 533   2          case bi_directional_storbing: 
 534   2            bi_directional_storbing_driver_init();
 535   2            display_driver = bi_directional_storbing_driver;
 536   2            cycle_params = cycle_for_bi_directional_storbing;
 537   2            cycle_reached = cycle_reached_bi_directional_storbing;
 538   2            break;
 539   2          case steady_on: 
 540   2            // steady_burn_driver_init();
 541   2            // display_driver = steady_burn_driver;
 542   2            // cycle_params = cycle_for_not_effective_default;
 543   2            break;    
 544   2          case sensor:
 545   2            // com_isr -> display_mode_set := sensor -> sensor_init
 546   2            // no other routine direct called 
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 10  

 547   2            break;
 548   2          default:
 549   2            break; 
 550   2        }
 551   1        reset_counter_for_cycle();
 552   1        // override flag -> YES:  (slow)fade-in-out
 553   1        // override flag -> NO:   else
 554   1        lumins_level_fine_override_should_change(display_mode_logic);
 555   1        // dont't reset all counters
 556   1        //cycle_ctrl_enable();
 557   1      }
 558          
 559          void
 560          skip_to_next_display_if_should() {
 561   1        if(display_mode_set == in_wave || display_mode_logic == in_wave)
 562   1        {
 563   2          in_wave_counter ++;
 564   2          if(in_wave_counter == 4)
 565   2          {
 566   3            in_wave_counter = 0;
 567   3          }
 568   2          cycle_params = cycle_for_in_wave[in_wave_counter];
 569   2        }
 570   1        if(display_mode_set == combination)
 571   1        {
 572   2          --counter_for_minute;
 573   2          if(!counter_for_minute)
 574   2          {
 575   3            counter_for_minute = 6; 
 576   3            display_mode_logic = next_display_mode[display_mode_logic - next_display_mode_from];
 577   3            display_mode_logic_changed();
 578   3          }
 579   2      
 580   2        }
 581   1      
 582   1      }
 583          /*
 584          * params <lumins_level_t> lumins: lumins_level_min to lumins_level_max
 585          * params <u8> deviation: 0 - 9
 586          * 
 587          */
 588          static u16 
 589          recalibrate_phase_delay(const lumins_level_t lumins, const u8 deviation) {
 590   1        if (lumins == lumins_level_max) {
 591   2        //  return current_phase_delay[index_of(lumins_level_max)];
 592   2          return current_phase_delay[index_of(lumins_level_max)];
 593   2        } else if (lumins == lumins_level_min) {
 594   2          u16 phase_delay_adjust = (fade_in_out_fine_grained_level - deviation) * lumins_level_min_deviation_inter
             -val_for_60Hz;
 595   2          // lumins_level_min ------ 1 ------ 2 ------ ... ------ 9 ------- lumins_level_min + 1
 596   2          return current_phase_delay[0] + phase_delay_adjust;
 597   2        } else {
 598   2          u16 phase_delay_delta =current_phase_delay[index_of(lumins)] - current_phase_delay[lumins];
 599   2          u16 phase_delay_interval = phase_delay_delta / fade_in_out_fine_grained_level;
 600   2          return current_phase_delay[index_of(lumins)] - phase_delay_interval * deviation;
 601   2        }
 602   1      }
 603          
 604          static u16 find_period_max_in_buffer() {
 605   1        u16 current_max = 0;
 606   1        u8 i;
 607   1        for (i = PERIOD_MAX_SIZE; i; ) {
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 11  

 608   2          if (current_max < period_max_buffer[--i])
 609   2            current_max = period_max_buffer[i];
 610   2        }
 611   1        return current_max;
 612   1      }
 613          
 614          // 0
 615          static void
 616          combination_driver_init() {
 617   1        cycle_output[0] = ON;
 618   1        cycle_output[1] = ON;
 619   1        cycle_output[2] = ON;
 620   1        display_mode_logic = in_wave;
 621   1        counter_for_minute = 6;
 622   1        // cycle_params = cycle_for_flash1_directional;   // 3. dispatch cycle_params
 623   1        // cycle_reached = cycle_reached_flash1_directional;
 624   1        display_mode_logic_changed();
 625   1      }
 626          
 627          // 1
 628          // in_wave
 629          static void 
 630          in_wave_driver(void) {
 631   1        u8 i,current_progress[3];
 632   1        u16 current_counter = counter_for_cycle;
 633   1        u16 progress = (current_counter * 100UL) / cycle_params[10];
 634   1        if(current_interval == 0){
 635   2          current_progress[0] = 100 - progress;
 636   2          current_progress[1] = 66 - progress;
 637   2          current_progress[2] = 33 - progress;
 638   2        }else if(current_interval == 1){
 639   2          current_progress[0] = 66 - progress;
 640   2          current_progress[1] = 33 - progress;
 641   2          current_progress[2] = progress;
 642   2        }else if(current_interval == 2){
 643   2          current_progress[0] = 50 - progress;
 644   2          current_progress[1] = 17 - progress;
 645   2          current_progress[2] = 17 + progress;
 646   2        }else if(current_interval == 3){
 647   2          current_progress[0] = 33 - progress;
 648   2          current_progress[1] = progress;
 649   2          current_progress[2] = 33 + progress;
 650   2        }else if(current_interval == 4){
 651   2          current_progress[0] = 17 - progress;
 652   2          current_progress[1] = progress + 17;
 653   2          current_progress[2] = progress + 50;
 654   2        }else if(current_interval == 5){
 655   2          current_progress[0] = progress;
 656   2          current_progress[1] = progress + 33;
 657   2          current_progress[2] = progress + 66;
 658   2        }else if(current_interval == 6){
 659   2          current_progress[0] = progress + 33;
 660   2          current_progress[1] = progress + 66;
 661   2          current_progress[2] = 100 - progress;
 662   2        }else if(current_interval == 7){
 663   2          current_progress[0] = progress + 50;
 664   2          current_progress[1] = progress + 83;
 665   2          current_progress[2] = 83 - progress;
 666   2        }else if(current_interval == 8){
 667   2          current_progress[0] = progress + 66;
 668   2          current_progress[1] = 100 - progress;
 669   2          current_progress[2] = 66 - progress;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 12  

 670   2        }else if(current_interval == 9){
 671   2          current_progress[0] = progress + 83;
 672   2          current_progress[1] = 83 - progress;
 673   2          current_progress[2] = 50 - progress;
 674   2        }
 675   1        for (i = 0; i < 3; ++i)
 676   1        {
 677   2          lumins_level_logic_prepared[i] = current_progress[i] / fade_in_out_fine_grained_level;
 678   2          lumins_level_deviation[i] = current_progress[i] - lumins_level_logic_prepared[i] * fade_in_out_fine_grai
             -ned_level;
 679   2        }
 680   1      }
 681          
 682          static void
 683          in_wave_driver_init() {
 684   1        cycle_output[0] = ON;
 685   1        cycle_output[1] = ON;
 686   1        cycle_output[2] = ON;
 687   1        current_interval = 0;
 688   1        in_wave_counter = 0;
 689   1      }
 690          
 691          
 692          static void 
 693          cycle_reached_in_wave(u16 cycle) {
 694   1        if(cycle >= cycle_params[current_interval])
 695   1        {
 696   2          ++  current_interval;
 697   2          if(current_interval == 10)
 698   2            current_interval = 0;
 699   2          reset_counter_for_cycle();
 700   2        }
 701   1      }
 702          
 703          // 2
 704          // sequential
 705          static void 
 706          sequential_driver(void) {
 707   1        u8 i,current_progress[3];
 708   1        u16 current_counter = counter_for_cycle;
 709   1        u16 progress = (current_counter * 100UL) / cycle_params[0];
 710   1        if(current_interval == 0){
 711   2          current_progress[0] = 0;
 712   2          current_progress[1] = 0;
 713   2          current_progress[2] = progress;
 714   2        }else if(current_interval == 1){
 715   2          current_progress[0] = 0;
 716   2          current_progress[1] = progress;
 717   2          current_progress[2] = 100 - progress;
 718   2        }else if(current_interval == 2){
 719   2          current_progress[0] = 0;
 720   2          current_progress[1] = 50 + progress;
 721   2          current_progress[2] = 50 - progress;
 722   2        }else if(current_interval == 3){
 723   2          current_progress[0] = progress;
 724   2          current_progress[1] = 100 - progress;
 725   2          current_progress[2] = 0;
 726   2        }else if(current_interval == 4){
 727   2          current_progress[0] = 50 + progress;
 728   2          current_progress[1] = 50 - progress;
 729   2          current_progress[2] = 0;
 730   2        }else if(current_interval == 5){
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 13  

 731   2          current_progress[0] = 100 - progress;
 732   2          current_progress[1] = 0;
 733   2          current_progress[2] = 0;
 734   2        }
 735   1        for (i = 0; i < 3; ++i)
 736   1        {
 737   2          lumins_level_logic_prepared[i] = current_progress[i] / fade_in_out_fine_grained_level;
 738   2          lumins_level_deviation[i] = current_progress[i] - lumins_level_logic_prepared[i] * fade_in_out_fine_grai
             -ned_level;
 739   2        }
 740   1      }
 741          
 742          static void
 743          sequential_driver_init() {
 744   1        cycle_output[0] = OFF;
 745   1        cycle_output[1] = OFF;
 746   1        cycle_output[2] = ON;
 747   1        current_interval = 0;
 748   1        counter_for_current_cycle = 0;
 749   1        sequential_cycle_counter = cycle_counter_for_sequential_per_interval[counter_for_current_cycle];
 750   1      }
 751          
 752          static void 
 753          cycle_reached_sequential(u16 cycle) 
 754          {
 755   1        if(cycle >= cycle_params[current_interval])
 756   1        {
 757   2          if(current_interval == 0)
 758   2          {
 759   3            cycle_output[0] = OFF;
 760   3            cycle_output[1] = ON;
 761   3            cycle_output[2] = ON;
 762   3          }
 763   2          if(current_interval == 2)
 764   2          {
 765   3            cycle_output[0] = ON;
 766   3            cycle_output[1] = ON;
 767   3            cycle_output[2] = OFF;
 768   3          }
 769   2          if(current_interval == 4)
 770   2          {
 771   3            cycle_output[0] = ON;
 772   3            cycle_output[1] = OFF;
 773   3            cycle_output[2] = OFF;
 774   3          }
 775   2          if(current_interval == 5)
 776   2          {
 777   3            cycle_output[0] = OFF;
 778   3            cycle_output[1] = OFF;
 779   3            cycle_output[2] = ON;
 780   3          }
 781   2          ++  current_interval;
 782   2          if(current_interval == 6)
 783   2          {
 784   3            current_interval = 0;
 785   3            -- sequential_cycle_counter;
 786   3            if(sequential_cycle_counter == 0)
 787   3            {
 788   4              counter_for_current_cycle++;
 789   4              if(counter_for_current_cycle == 5)
 790   4              {
 791   5                counter_for_current_cycle = 0;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 14  

 792   5              }
 793   4              cycle_params = cycle_for_sequential[counter_for_current_cycle]; 
 794   4              sequential_cycle_counter = cycle_counter_for_sequential_per_interval[counter_for_current_cycle];
 795   4            }
 796   3          }
 797   2          reset_counter_for_cycle();
 798   2        }
 799   1      }
 800          
 801          
 802          // 3
 803          // slow_glo
 804          static void 
 805          slow_glo_driver(void) {
 806   1        u8 i,current_progress[3];
 807   1        u16 current_counter = counter_for_cycle;
 808   1        u16 progress = (current_counter * 100UL) / cycle_params[0];
 809   1        if(current_interval == 0){
 810   2          current_progress[0] = progress;
 811   2          current_progress[1] = 0;
 812   2          current_progress[2] = 0;
 813   2        }else if(current_interval == 1){
 814   2          current_progress[0] = 100 - progress;
 815   2          current_progress[1] = 0;
 816   2          current_progress[2] = 0;
 817   2        }else if(current_interval == 2){
 818   2          current_progress[0] = 66 - progress;
 819   2          current_progress[1] = progress;
 820   2          current_progress[2] = 0;
 821   2        }else if(current_interval == 3){
 822   2          current_progress[0] = 33 - progress;
 823   2          current_progress[1] = progress + 33;
 824   2          current_progress[2] = 0;
 825   2        }else if(current_interval == 4){
 826   2          current_progress[0] = 0;
 827   2          current_progress[1] = progress + 66;
 828   2          current_progress[2] = 0;
 829   2        }else if(current_interval == 5){
 830   2          current_progress[0] = 0;
 831   2          current_progress[1] = 100 - progress;
 832   2          current_progress[2] = 0;
 833   2        }else if(current_interval == 6){
 834   2          current_progress[0] = 0;
 835   2          current_progress[1] = 66 - progress;
 836   2          current_progress[2] = progress;
 837   2        }else if(current_interval == 7){
 838   2          current_progress[0] = 0;
 839   2          current_progress[1] = 33 - progress;
 840   2          current_progress[2] = progress + 33;
 841   2        }else if(current_interval == 8){
 842   2          current_progress[0] = 0;
 843   2          current_progress[1] = 0;
 844   2          current_progress[2] = progress + 66;
 845   2        }else if(current_interval == 9){
 846   2          current_progress[0] = 0;
 847   2          current_progress[1] = 0;
 848   2          current_progress[2] = 100 - progress;
 849   2        }else if(current_interval == 10){
 850   2          current_progress[0] = 0;
 851   2          current_progress[1] = 0;
 852   2          current_progress[2] = 0;
 853   2        }
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 15  

 854   1        for (i = 0; i < 3; ++i)
 855   1        {
 856   2          lumins_level_logic_prepared[i] = current_progress[i] / fade_in_out_fine_grained_level;
 857   2          lumins_level_deviation[i] = current_progress[i] - lumins_level_logic_prepared[i] * fade_in_out_fine_grai
             -ned_level;
 858   2        }
 859   1      }
 860          
 861          static void
 862          slow_glo_driver_init() {
 863   1        cycle_output[0] = ON;
 864   1        cycle_output[1] = OFF;
 865   1        cycle_output[2] = OFF;
 866   1        current_interval = 0;
 867   1        slow_glo_counter = 0;
 868   1      }
 869          
 870          
 871          static void 
 872          cycle_reached_slow_glo(u16 cycle) {
 873   1        if(cycle >= cycle_params[current_interval])
 874   1        {
 875   2          if(current_interval == 1)
 876   2          {
 877   3            cycle_output[0] = ON;
 878   3            cycle_output[1] = ON;
 879   3            cycle_output[2] = OFF;
 880   3          }
 881   2          if(current_interval == 3)
 882   2          {
 883   3            cycle_output[0] = OFF;
 884   3            cycle_output[1] = ON;
 885   3            cycle_output[2] = OFF;
 886   3          }
 887   2          if(current_interval == 5)
 888   2          {
 889   3            cycle_output[0] = OFF;
 890   3            cycle_output[1] = ON;
 891   3            cycle_output[2] = ON;
 892   3          }
 893   2          if(current_interval == 7)
 894   2          {
 895   3            cycle_output[0] = OFF;
 896   3            cycle_output[1] = OFF;
 897   3            cycle_output[2] = ON;
 898   3          }
 899   2          if(current_interval == 9)
 900   2          {
 901   3            cycle_output[0] = OFF;
 902   3            cycle_output[1] = OFF;
 903   3            cycle_output[2] = OFF;
 904   3          }
 905   2          if(current_interval == 10)
 906   2          {
 907   3            cycle_output[0] = ON;
 908   3            cycle_output[1] = OFF;
 909   3            cycle_output[2] = OFF;
 910   3          }
 911   2          ++  current_interval;
 912   2          if(current_interval == 11)
 913   2          {
 914   3            current_interval = 0;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 16  

 915   3            ++ slow_glo_counter;
 916   3            if(slow_glo_counter == 4)
 917   3            {
 918   4              slow_glo_counter = 0;
 919   4            }
 920   3            cycle_params = cycle_for_slow_glo[slow_glo_counter];
 921   3          }
 922   2          reset_counter_for_cycle();
 923   2        }
 924   1      }
 925          
 926          // 4
 927          // chasing_flash
 928          static void 
 929          chasing_flash_driver(void) {
 930   1        u8 i;
 931   1        u16 current_counter = counter_for_cycle;
 932   1        for(i = 0; i < 3; i++)
 933   1        {
 934   2          u16 progress = (current_counter * 100UL) / (cycle_for_twinkle_flash[current_interval]) ;
 935   2          u16 reversed_cycle_rate_of_progress = 100 - progress;
 936   2      
 937   2          if (fade_in_out_flag[i] == RISE) {
 938   3          // 0 -> 10
 939   3            lumins_level_logic_prepared[i] = progress / fade_in_out_fine_grained_level;
 940   3            lumins_level_deviation[i] = progress - lumins_level_logic_prepared[i] * fade_in_out_fine_grained_level;
 941   3          } else { // FALL
 942   3          // 10 -> 0
 943   3            lumins_level_logic_prepared[i] = reversed_cycle_rate_of_progress / fade_in_out_fine_grained_level;
 944   3            lumins_level_deviation[i] = reversed_cycle_rate_of_progress - lumins_level_logic_prepared[i] * fade_in_
             -out_fine_grained_level;
 945   3          }
 946   2        }
 947   1      }
 948          
 949          static void
 950          chasing_flash_driver_init() {
 951   1        cycle_output[0] = ON;
 952   1        cycle_output[1] = OFF;
 953   1        cycle_output[2] = OFF;
 954   1        fade_in_out_flag[0] = RISE;
 955   1        fade_in_out_flag[1] = RISE;
 956   1        fade_in_out_flag[2] = RISE; 
 957   1        lumins_level_logic_prepared[0] = lumins_level_min;
 958   1        lumins_level_logic_prepared[1] = lumins_level_min;
 959   1        lumins_level_logic_prepared[2] = lumins_level_min;
 960   1        current_interval = 0;
 961   1        counter_for_current_cycle = 0;
 962   1        chasing_flash_cycle_counter = cycle_counter_for_chasing_flash_per_interval[counter_for_current_cycle];
 963   1      }
 964          
 965          
 966          static void 
 967          cycle_reached_chasing_flash(u16 cycle) {
 968   1        u8 i;
 969   1        if(cycle >= cycle_params[current_interval])
 970   1        {
 971   2          if(counter_for_current_cycle == 0)
 972   2          {
 973   3            for(i = 0; i < 3; i++)
 974   3            {
 975   4              if(fade_in_out_flag[i]) fade_in_out_flag[i] = 0;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 17  

 976   4              else fade_in_out_flag[i] = 1;
 977   4            }
 978   3            if(current_interval == 3)
 979   3            {
 980   4              cycle_output[0] = ON;
 981   4              cycle_output[1] = ON;
 982   4              cycle_output[2] = OFF;
 983   4            }
 984   3            if(current_interval == 7)
 985   3            {
 986   4              cycle_output[0] = OFF;
 987   4              cycle_output[1] = ON;
 988   4              cycle_output[2] = ON;
 989   4            }
 990   3            if(current_interval == 11)
 991   3            {
 992   4              cycle_output[0] = OFF;
 993   4              cycle_output[1] = OFF;
 994   4              cycle_output[2] = ON;
 995   4            }
 996   3            if(current_interval == 15)
 997   3            {
 998   4              cycle_output[0] = ON;
 999   4              cycle_output[1] = OFF;
1000   4              cycle_output[2] = OFF;
1001   4            }
1002   3          }
1003   2          if(counter_for_current_cycle == 1)
1004   2          {
1005   3            if(current_interval == 0)
1006   3            {
1007   4              cycle_output[0] = OFF;
1008   4              cycle_output[1] = OFF;
1009   4              cycle_output[2] = OFF;
1010   4            }
1011   3            if(current_interval == 3)
1012   3            {
1013   4              cycle_output[0] = ON;
1014   4              cycle_output[1] = ON;
1015   4              cycle_output[2] = ON;
1016   4            }
1017   3            if(current_interval == 6)
1018   3            {
1019   4              cycle_output[0] = OFF;
1020   4              cycle_output[1] = OFF;
1021   4              cycle_output[2] = OFF;
1022   4            }
1023   3            if(current_interval == 10)
1024   3            {
1025   4              cycle_output[0] = ON;
1026   4              cycle_output[1] = ON;
1027   4              cycle_output[2] = ON;
1028   4            }
1029   3            if(current_interval == 14)
1030   3            {
1031   4              cycle_output[0] = OFF;
1032   4              cycle_output[1] = OFF;
1033   4              cycle_output[2] = OFF;
1034   4            }
1035   3      
1036   3          }
1037   2          if(counter_for_current_cycle == 2)
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 18  

1038   2          {
1039   3            for(i = 0; i < 3; i++)
1040   3            {
1041   4              if(fade_in_out_flag[i]) fade_in_out_flag[i] = 0;
1042   4              else fade_in_out_flag[i] = 1;
1043   4            }
1044   3            if(current_interval == 3)
1045   3            {
1046   4              cycle_output[2] = ON;
1047   4              cycle_output[1] = ON;
1048   4              cycle_output[0] = OFF;
1049   4            }
1050   3            if(current_interval == 7)
1051   3            {
1052   4              cycle_output[2] = OFF;
1053   4              cycle_output[1] = ON;
1054   4              cycle_output[0] = ON;
1055   4            }
1056   3            if(current_interval == 11)
1057   3            {
1058   4              cycle_output[2] = OFF;
1059   4              cycle_output[1] = OFF;
1060   4              cycle_output[0] = ON;
1061   4            }
1062   3            if(current_interval == 15)
1063   3            {
1064   4              cycle_output[2] = ON;
1065   4              cycle_output[1] = OFF;
1066   4              cycle_output[0] = OFF;
1067   4            }
1068   3          }
1069   2          if(counter_for_current_cycle == 3)
1070   2          {
1071   3            if(current_interval == 0)
1072   3            {
1073   4              cycle_output[0] = OFF;
1074   4              cycle_output[1] = OFF;
1075   4              cycle_output[2] = OFF;
1076   4            }
1077   3            if(current_interval == 4)
1078   3            {
1079   4              cycle_output[0] = ON;
1080   4              cycle_output[1] = ON;
1081   4              cycle_output[2] = ON;
1082   4            }
1083   3            if(current_interval == 8)
1084   3            {
1085   4              cycle_output[0] = OFF;
1086   4              cycle_output[1] = OFF;
1087   4              cycle_output[2] = OFF;
1088   4            }
1089   3            if(current_interval == 12)
1090   3            {
1091   4              cycle_output[0] = ON;
1092   4              cycle_output[1] = ON;
1093   4              cycle_output[2] = ON;
1094   4            }
1095   3            if(current_interval == 14)
1096   3            {
1097   4              cycle_output[0] = OFF;
1098   4              cycle_output[1] = OFF;
1099   4              cycle_output[2] = OFF;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 19  

1100   4            }
1101   3          }
1102   2          current_interval ++;
1103   2          if(current_interval == 16)
1104   2          {
1105   3            current_interval = 0;
1106   3            -- chasing_flash_cycle_counter;
1107   3            if(chasing_flash_cycle_counter == 0)
1108   3            {
1109   4              counter_for_current_cycle++;
1110   4              if(counter_for_current_cycle == 4)
1111   4              {
1112   5                counter_for_current_cycle = 0;
1113   5              }
1114   4              if(counter_for_current_cycle == 0)
1115   4              {
1116   5                cycle_output[0] = ON;
1117   5                cycle_output[1] = OFF;
1118   5                cycle_output[2] = OFF;
1119   5              }
1120   4              if(counter_for_current_cycle == 2)
1121   4              {
1122   5                cycle_output[2] = ON;
1123   5                cycle_output[1] = OFF;
1124   5                cycle_output[0] = OFF;
1125   5              }
1126   4              cycle_params = cycle_for_chasing_flash[counter_for_current_cycle]; 
1127   4              chasing_flash_cycle_counter = cycle_counter_for_chasing_flash_per_interval[counter_for_current_cycle];
1128   4            }
1129   3          }
1130   2          reset_counter_for_cycle();
1131   2        }
1132   1      }
1133          // 5
1134          // slow_fade
1135          static void 
1136          slow_fade_driver(void) {
1137   1        u8 i;
1138   1        u16 current_counter = counter_for_cycle;
1139   1        for(i = 0; i < 3; i++)
1140   1        {
1141   2          u16 progress = (current_counter * 100UL) / (cycle_for_slow_fade[current_interval]) ;
1142   2          u16 reversed_cycle_rate_of_progress = 100 - progress;
1143   2      
1144   2          if (fade_in_out_flag[i] == RISE) {
1145   3          // 0 -> 10
1146   3            lumins_level_logic_prepared[i] = progress / fade_in_out_fine_grained_level;
1147   3            lumins_level_deviation[i] = progress - lumins_level_logic_prepared[i] * fade_in_out_fine_grained_level;
1148   3          } else { // FALL
1149   3          // 10 -> 0
1150   3            lumins_level_logic_prepared[i] = reversed_cycle_rate_of_progress / fade_in_out_fine_grained_level;
1151   3            lumins_level_deviation[i] = reversed_cycle_rate_of_progress - lumins_level_logic_prepared[i] * fade_in_
             -out_fine_grained_level;
1152   3          }
1153   2        }
1154   1      }
1155          
1156          static void
1157          slow_fade_driver_init() {
1158   1        cycle_output[0] = ON;
1159   1        cycle_output[1] = ON;
1160   1        cycle_output[2] = ON;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 20  

1161   1        fade_in_out_flag[0] = RISE;
1162   1        fade_in_out_flag[1] = RISE;
1163   1        fade_in_out_flag[2] = RISE; 
1164   1        lumins_level_logic_prepared[0] = lumins_level_min;
1165   1        lumins_level_logic_prepared[1] = lumins_level_min;
1166   1        lumins_level_logic_prepared[2] = lumins_level_min;
1167   1        current_interval = 0;
1168   1      }
1169          
1170          
1171          static void 
1172          cycle_reached_slow_fade(u16 cycle) {
1173   1        u8 i;
1174   1        if(cycle >= cycle_params[current_interval])
1175   1        {
1176   2          for(i = 0; i < 3; i++)
1177   2          {
1178   3            if(fade_in_out_flag[i]) fade_in_out_flag[i] = 0;
1179   3            else fade_in_out_flag[i] = 1;
1180   3          }
1181   2          current_interval ++;
1182   2          if(current_interval == 16)
1183   2          {
1184   3            current_interval = 0;
1185   3          }
1186   2          reset_counter_for_cycle();
1187   2        }
1188   1      }
1189          
1190          
1191          // 6
1192          // twinkle_flash
1193          static void 
1194          twinkle_flash_driver(void) {
1195   1        u8 i;
1196   1        u16 current_counter = counter_for_cycle;
1197   1        for(i = 0; i < 3; i++)
1198   1        {
1199   2          u16 progress = (current_counter * 100UL) / (cycle_for_twinkle_flash[current_interval]) ;
1200   2          u16 reversed_cycle_rate_of_progress = 100 - progress;
1201   2      
1202   2          if (fade_in_out_flag[i] == RISE) {
1203   3          // 0 -> 10
1204   3            lumins_level_logic_prepared[i] = progress / fade_in_out_fine_grained_level;
1205   3            lumins_level_deviation[i] = progress - lumins_level_logic_prepared[i] * fade_in_out_fine_grained_level;
1206   3          } else { // FALL
1207   3          // 10 -> 0
1208   3            lumins_level_logic_prepared[i] = reversed_cycle_rate_of_progress / fade_in_out_fine_grained_level;
1209   3            lumins_level_deviation[i] = reversed_cycle_rate_of_progress - lumins_level_logic_prepared[i] * fade_in_
             -out_fine_grained_level;
1210   3          }
1211   2        }
1212   1      }
1213          
1214          static void
1215          twinkle_flash_driver_init() {
1216   1        cycle_output[0] = ON;
1217   1        cycle_output[1] = OFF;
1218   1        cycle_output[2] = OFF;
1219   1        fade_in_out_flag[0] = RISE;
1220   1        fade_in_out_flag[1] = RISE;
1221   1        fade_in_out_flag[2] = RISE; 
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 21  

1222   1        lumins_level_logic_prepared[0] = lumins_level_min;
1223   1        lumins_level_logic_prepared[1] = lumins_level_min;
1224   1        lumins_level_logic_prepared[2] = lumins_level_min;
1225   1        current_interval = 0;
1226   1      }
1227          
1228          
1229          static void 
1230          cycle_reached_twinkle_flash(u16 cycle) {
1231   1        u8 i;
1232   1        if(cycle >= cycle_params[current_interval])
1233   1        {
1234   2          for(i = 0; i < 3; i++)
1235   2          {
1236   3            if(fade_in_out_flag[i]) fade_in_out_flag[i] = 0;
1237   3            else fade_in_out_flag[i] = 1;
1238   3          }
1239   2          if(current_interval == 3)
1240   2          {
1241   3            cycle_output[0] = ON;
1242   3            cycle_output[1] = ON;
1243   3            cycle_output[2] = OFF;
1244   3          }
1245   2          if(current_interval == 7)
1246   2          {
1247   3            cycle_output[0] = OFF;
1248   3            cycle_output[1] = ON;
1249   3            cycle_output[2] = ON;
1250   3          }
1251   2          if(current_interval == 11)
1252   2          {
1253   3            cycle_output[0] = OFF;
1254   3            cycle_output[1] = OFF;
1255   3            cycle_output[2] = ON;
1256   3          }
1257   2          if(current_interval == 15)
1258   2          {
1259   3            cycle_output[0] = ON;
1260   3            cycle_output[1] = OFF;
1261   3            cycle_output[2] = OFF;
1262   3          }
1263   2          current_interval ++;
1264   2          if(current_interval == 16)
1265   2          {
1266   3            current_interval = 0;
1267   3          }
1268   2          reset_counter_for_cycle();
1269   2        }
1270   1      }
1271          
1272          //7
1273          //stacking_flash
1274          static void 
1275          stacking_flash_driver(void) {
1276   1        lumins_level_logic_prepared[0] = lumins_level_set;
1277   1        lumins_level_logic_prepared[1] = lumins_level_set;
1278   1        lumins_level_logic_prepared[2] = lumins_level_set;
1279   1      }
1280          
1281          static void
1282          stacking_flash_driver_init() {
1283   1        cycle_output[0] = ON;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 22  

1284   1        cycle_output[1] = OFF;
1285   1        cycle_output[2] = OFF;
1286   1        current_interval = 0;
1287   1        lumins_level_logic_prepared[0] = lumins_level_set;
1288   1        lumins_level_logic_prepared[1] = lumins_level_set;
1289   1        lumins_level_logic_prepared[2] = lumins_level_set;
1290   1      }
1291          
1292          
1293          static void 
1294          cycle_reached_stacking_flash(u16 cycle) {
1295   1      
1296   1        if(cycle >= cycle_params[speed_level])
1297   1        {
1298   2          if(current_interval == 0){
1299   3      //      cycle_output[0] = OFF;
1300   3            cycle_output[1] = ON;
1301   3      //      cycle_output[2] = ON;
1302   3          }
1303   2          else if(current_interval == 1){
1304   3      //      cycle_output[0] = ON;
1305   3      //      cycle_output[1] = ON;
1306   3            cycle_output[2] = ON;
1307   3          }
1308   2          else if(current_interval == 2){
1309   3      //      cycle_output[0] = OFF;
1310   3      //      cycle_output[1] = ON;
1311   3      //      cycle_output[2] = ON;
1312   3          }
1313   2          else if(current_interval == 3){
1314   3      //         cycle_output[0] = OFF;
1315   3            // cycle_output[1] = ON;
1316   3             cycle_output[2] = OFF;
1317   3          }
1318   2          else if(current_interval == 4){
1319   3      //      cycle_output[0] = OFF;
1320   3            cycle_output[1] = OFF;
1321   3            // cycle_output[2] = ON;
1322   3          }
1323   2          else if(current_interval == 5){
1324   3            cycle_output[0] = OFF;
1325   3      //      cycle_output[1] = OFF;
1326   3            //cycle_output[2] = OFF;
1327   3          }
1328   2          else if(current_interval == 6)
1329   2          {
1330   3            cycle_output[0] = ON;
1331   3      //      cycle_output[1] = OFF;
1332   3            //cycle_output[2] = OFF;
1333   3          }
1334   2      //    else if(current_interval == 11){
1335   2      //      cycle_output[0] = ON;
1336   2      // //     cycle_output[1] = OFF;
1337   2      // //     cycle_output[2] = OFF;
1338   2      //    }
1339   2      //    // 6 -> 10 继续关闭全部
1340   2      //    else{ 
1341   2      // //     cycle_output[0] = OFF;
1342   2      // //     cycle_output[1] = OFF;
1343   2      // //     cycle_output[2] = OFF;
1344   2      //    }
1345   2          reset_counter_for_cycle();
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 23  

1346   2          ++ current_interval;
1347   2          if(current_interval == 7)
1348   2            current_interval = 0;
1349   2        }
1350   1      }
1351          
1352          // 8
1353          // flash_and_chase
1354          static void 
1355          flash_and_chase_driver(void) {
1356   1        lumins_level_logic_prepared[0] = lumins_level_set;
1357   1        lumins_level_logic_prepared[1] = lumins_level_set;
1358   1        lumins_level_logic_prepared[2] = lumins_level_set;
1359   1      }
1360          
1361          static void
1362          flash_and_chase_driver_init() {
1363   1        cycle_output[0] = OFF;
1364   1        cycle_output[1] = OFF;
1365   1        cycle_output[2] = OFF;
1366   1        current_interval = 0;
1367   1        lumins_level_logic_prepared[0] = lumins_level_set;
1368   1        lumins_level_logic_prepared[1] = lumins_level_set;
1369   1        lumins_level_logic_prepared[2] = lumins_level_set;
1370   1      }
1371          
1372          
1373          static void 
1374          cycle_reached_flash_and_chase(u16 cycle) {
1375   1      
1376   1        if(cycle >= cycle_params[speed_level])
1377   1        {
1378   2          if(current_interval == 0){
1379   3            cycle_output[0] = ON;
1380   3            cycle_output[1] = OFF;
1381   3            cycle_output[2] = OFF;
1382   3          }
1383   2          else if(current_interval == 1){
1384   3            cycle_output[0] = ON;
1385   3            cycle_output[1] = ON;
1386   3            cycle_output[2] = OFF;
1387   3          }
1388   2          else if(current_interval == 2){
1389   3            cycle_output[0] = ON;
1390   3            cycle_output[1] = ON;
1391   3            cycle_output[2] = ON;
1392   3          }
1393   2          else if(current_interval == 3){
1394   3            cycle_output[0] = OFF;
1395   3            cycle_output[1] = OFF;
1396   3            cycle_output[2] = OFF;
1397   3          }
1398   2          reset_counter_for_cycle();
1399   2          ++ current_interval;
1400   2          if(current_interval == 4)
1401   2            current_interval = 0;
1402   2        }
1403   1      }
1404          
1405          // 9
1406          // random_flashing
1407          static void 
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 24  

1408          random_flashing_driver(void) {
1409   1        lumins_level_logic_prepared[0] = lumins_level_set;
1410   1        lumins_level_logic_prepared[1] = lumins_level_set;
1411   1        lumins_level_logic_prepared[2] = lumins_level_set;
1412   1      }
1413          
1414          static void
1415          random_flashing_driver_init() {
1416   1        cycle_output[0] = OFF;
1417   1        cycle_output[1] = OFF;
1418   1        cycle_output[2] = OFF;
1419   1        current_interval = 0;
1420   1        lumins_level_logic_prepared[0] = lumins_level_set;
1421   1        lumins_level_logic_prepared[1] = lumins_level_set;
1422   1        lumins_level_logic_prepared[2] = lumins_level_set;
1423   1      }
1424          
1425          
1426          static void 
1427          cycle_reached_random_flashing(u16 cycle) {
1428   1      
1429   1        if(cycle >= cycle_params[speed_level])
1430   1        {
1431   2          if(current_interval == 0){
1432   3            cycle_output[0] = OFF;
1433   3            cycle_output[1] = ON;
1434   3            cycle_output[2] = OFF;
1435   3          }
1436   2          else if(current_interval == 1){
1437   3            cycle_output[0] = ON;
1438   3            cycle_output[1] = ON;
1439   3            cycle_output[2] = ON;
1440   3          }
1441   2          else if(current_interval == 2){
1442   3            cycle_output[0] = OFF;
1443   3            cycle_output[1] = OFF;
1444   3            cycle_output[2] = OFF;
1445   3          }
1446   2          reset_counter_for_cycle();
1447   2          ++ current_interval;
1448   2          if(current_interval == 3)
1449   2            current_interval = 0;
1450   2        }
1451   1      }
1452          
1453          // 10
1454          // pulsing
1455          static void 
1456          pulsing_driver(void) {
1457   1        u8 i;
1458   1        for(i = 0; i < 3; i++)
1459   1          lumins_level_logic_prepared[i] = (dim_in_out_flag == HALF) ? lumins_level_set >> 1 : lumins_level_set;
1460   1      }
1461          
1462          static void
1463          pulsing_driver_init() {
1464   1        cycle_output[0] = ON;
1465   1        cycle_output[1] = ON;
1466   1        cycle_output[2] = ON;
1467   1        dim_in_out_flag = HALF;
1468   1        current_interval = 0;
1469   1        lumins_level_logic_prepared[0] = lumins_level_set;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 25  

1470   1        lumins_level_logic_prepared[1] = lumins_level_set;
1471   1        lumins_level_logic_prepared[2] = lumins_level_set;
1472   1      }
1473          
1474          static void 
1475          cycle_reached_pulsing(u16 cycle) {
1476   1        if(cycle >= cycle_params[speed_level]){
1477   2          reverse_dim_in_out_flag();
1478   2          reset_counter_for_cycle();
1479   2        }
1480   1      }
1481          
1482          // 11
1483          // sequential_flashing
1484          static void 
1485          sequential_flashing_driver()
1486          {
1487   1        lumins_level_logic_prepared[0] = lumins_level_set;
1488   1        lumins_level_logic_prepared[1] = lumins_level_set;
1489   1        lumins_level_logic_prepared[2] = lumins_level_set;
1490   1      }
1491          
1492          static void
1493          sequential_flashing_driver_init() {
1494   1        cycle_output[0] = OFF;
1495   1        cycle_output[1] = OFF;
1496   1        cycle_output[2] = OFF;
1497   1        lumins_level_logic_prepared[0] = lumins_level_set;
1498   1        lumins_level_logic_prepared[1] = lumins_level_set;
1499   1        lumins_level_logic_prepared[2] = lumins_level_set;
1500   1        current_interval = 0;
1501   1      }
1502          
1503          static void 
1504          cycle_reached_sequential_flashing(u16 cycle)
1505          {
1506   1        if(cycle >= cycle_params[speed_level])
1507   1        {
1508   2          if(current_interval == 0){
1509   3            cycle_output[0] = ON;
1510   3            cycle_output[1] = OFF;
1511   3            cycle_output[2] = OFF;
1512   3          }
1513   2          else if(current_interval == 1){
1514   3            cycle_output[0] = OFF;
1515   3            cycle_output[1] = ON;
1516   3            cycle_output[2] = OFF;
1517   3          }
1518   2          else if(current_interval == 2){
1519   3            cycle_output[0] = OFF;
1520   3            cycle_output[1] = OFF;
1521   3            cycle_output[2] = ON;
1522   3          }
1523   2      
1524   2          else if(current_interval == 3){
1525   3            cycle_output[0] = OFF;
1526   3            cycle_output[1] = OFF;
1527   3            cycle_output[2] = ON;
1528   3          }
1529   2          else if(current_interval == 4){
1530   3            cycle_output[0] = OFF;
1531   3            cycle_output[1] = ON;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 26  

1532   3            cycle_output[2] = OFF;
1533   3          }
1534   2          else if(current_interval == 5){
1535   3            cycle_output[0] = ON;
1536   3            cycle_output[1] = OFF;
1537   3            cycle_output[2] = OFF;
1538   3          }
1539   2          else if(current_interval == 6){
1540   3            cycle_output[0] = OFF;
1541   3            cycle_output[1] = OFF;
1542   3            cycle_output[2] = OFF;
1543   3          }
1544   2          reset_counter_for_cycle();
1545   2          ++ current_interval;
1546   2          if(current_interval == 7)
1547   2            current_interval = 0;
1548   2        }
1549   1      }
1550          
1551          // 12
1552          // bi_directional_storbing
1553          static void 
1554          bi_directional_storbing_driver(void) {
1555   1        if(current_interval == 0)
1556   1        {
1557   2          lumins_level_logic_prepared[0] = lumins_level_set;
1558   2          lumins_level_logic_prepared[1] = lumins_level_set;
1559   2          lumins_level_logic_prepared[2] = lumins_level_set;
1560   2        }
1561   1        if(current_interval == 8)
1562   1        {
1563   2          lumins_level_logic_prepared[0] = lumins_level_set >> 1;
1564   2          lumins_level_logic_prepared[1] = lumins_level_set >> 1;
1565   2          lumins_level_logic_prepared[2] = lumins_level_set >> 1;
1566   2        }
1567   1        if(current_interval == 16)
1568   1        {
1569   2          lumins_level_logic_prepared[0] = lumins_level_set >> 2;
1570   2          lumins_level_logic_prepared[1] = lumins_level_set >> 2;
1571   2          lumins_level_logic_prepared[2] = lumins_level_set >> 2;
1572   2        }
1573   1      }
1574          
1575          static void
1576          bi_directional_storbing_driver_init() {
1577   1        cycle_output[0] = ON;
1578   1        cycle_output[1] = ON;
1579   1        cycle_output[2] = ON;
1580   1        lumins_level_logic_prepared[0] = lumins_level_set;
1581   1        lumins_level_logic_prepared[1] = lumins_level_set;
1582   1        lumins_level_logic_prepared[2] = lumins_level_set;
1583   1        current_interval = 0;
1584   1      }
1585          
1586          static void 
1587          cycle_reached_bi_directional_storbing(u16 cycle) {
1588   1        u8 i;
1589   1        if(cycle >= cycle_params[speed_level])
1590   1        {
1591   2          for(i = 0; i < 3; i++)
1592   2          {
1593   3            if(cycle_output[i]) cycle_output[i] = 0;
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 27  

1594   3            else cycle_output[i] = 1;
1595   3          }
1596   2          reset_counter_for_cycle();
1597   2          ++ current_interval;
1598   2          if(current_interval == 25)
1599   2            current_interval = 0;
1600   2      
1601   2        }
1602   1      }
1603          
1604          // 13
1605          // steady_on
1606          static void 
1607          steady_on_driver(void) {
1608   1        lumins_level_logic_prepared[0] = lumins_level_set;
1609   1        lumins_level_logic_prepared[1] = lumins_level_set;
1610   1        lumins_level_logic_prepared[2] = lumins_level_set;
1611   1      }
1612          
1613          static void
1614          steady_on_driver_init() {
1615   1        cycle_output[0] = ON;
1616   1        cycle_output[1] = ON;
1617   1        cycle_output[2] = ON;
1618   1        lumins_level_logic_prepared[0] = lumins_level_set;
1619   1        lumins_level_logic_prepared[1] = lumins_level_set;
1620   1        lumins_level_logic_prepared[2] = lumins_level_set;
1621   1      }
1622          
1623          // 14
1624          /*
1625          * Sensor Mode
1626          */
1627          
1628          static void 
1629          sensor_driver() {
1630   1        u8 lumins_level_logic_prepared_for_deviation[3];
1631   1        // if (sensor_should_reinit_from_awake()) {
1632   1        //  sensor_driver_init();
1633   1        // } else {
1634   1        if(!--sensor_counter)
1635   1        {
1636   2          int level_to_average;
1637   2            u8 level_below_avg_threshold;
1638   2            u16 current_adc_max;
1639   2            sensor_counter = 4;
1640   2      
1641   2          // 6 * 60Hz period max
1642   2            period_max_buffer[period_max_index] = read_adc_period_max();
1643   2            refresh_adc_period_max();
1644   2            ++period_max_index;
1645   2            // 保留上一次亮度值
1646   2          lumins_level_logic_prepared_for_deviation[0] = lumins_level_logic_prepared[0];
1647   2          lumins_level_logic_prepared_for_deviation[1] = lumins_level_logic_prepared[1];
1648   2          lumins_level_logic_prepared_for_deviation[2] = lumins_level_logic_prepared[2];
1649   2      
1650   2            if (period_max_index == PERIOD_MAX_SIZE) 
1651   2            {
1652   3              // -------------------------------- sampling ----------------------------------
1653   3              period_max_index = 0;
1654   3      
1655   3              current_adc_max = find_period_max_in_buffer();
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 28  

1656   3      
1657   3              max_avg = max_sum >> AVG_BUFFER_SIZE_BIT;
1658   3      
1659   3            level_to_average = current_adc_max - max_avg;
1660   3            max_sum -= avg_buffer[max_avg_index];
1661   3            max_sum += current_adc_max;
1662   3            avg_buffer[max_avg_index] = current_adc_max;
1663   3            spiral_increase_q(max_avg_index, AVG_BUFFER_SIZE);
1664   3            if (sensor_initializing_finished())
1665   3              sensor_initializing = NO;
1666   3            // -------------------------------- choosing ----------------------------------
1667   3            // shift
1668   3            if (sensor_initializing)
1669   3            {
1670   4              lumins_level_logic_prepared[0] = lumins_level_min;
1671   4              lumins_level_logic_prepared[1] = lumins_level_min;
1672   4              lumins_level_logic_prepared[2] = lumins_level_min;
1673   4            }
1674   3            else 
1675   3            {
1676   4              max_avg = max_avg >> 2;
1677   4              if (belong_to_interval_lcro(max_avg, avg_range[0], avg_range[1])) {
1678   5                diff = diff_avg_range_1;
1679   5                level_below_avg_threshold = (below_avg_threshold[0]); 
1680   5              }
1681   4              else if (belong_to_interval_lcro(max_avg, avg_range[1], avg_range[2])) {
1682   5                diff = diff_avg_range_2;
1683   5                level_below_avg_threshold = (below_avg_threshold[1]); 
1684   5              }
1685   4              else if (belong_to_interval_lcro(max_avg, avg_range[2], avg_range[3])) {
1686   5                diff = diff_avg_range_3;
1687   5                level_below_avg_threshold = (below_avg_threshold[2]); 
1688   5              }
1689   4              else {
1690   5                diff = diff_avg_range_4;
1691   5                level_below_avg_threshold = (below_avg_threshold[3]); 
1692   5              }
1693   4              if (level_to_average < 0) 
1694   4              {
1695   5                level_to_average = -level_to_average;
1696   5                if (belong_to_interval_lc(level_to_average, level_below_avg_threshold))
1697   5                {
1698   6                    lumins_level_logic_prepared[0] = lumins_level_min;
1699   6                    lumins_level_logic_prepared[1] = lumins_level_min;
1700   6                    lumins_level_logic_prepared[2] = lumins_level_min;
1701   6                }
1702   5                else if (belong_to_interval_lcro(level_to_average, below_avg_threshhold_for_peace, level_below_avg_th
             -reshold))
1703   5                {
1704   6                    lumins_level_logic_prepared[0] = 1;
1705   6                    lumins_level_logic_prepared[1] = 1;
1706   6                    lumins_level_logic_prepared[2] = 1;
1707   6                }
1708   5                else  // 0 - below_avg_threshhold_for_peace
1709   5                {
1710   6                  lumins_level_logic_prepared[0] = lumins_level_peace;
1711   6                  lumins_level_logic_prepared[1] = lumins_level_peace;
1712   6                  lumins_level_logic_prepared[2] = lumins_level_peace;
1713   6                }
1714   5      
1715   5              } 
1716   4              else 
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 29  

1717   4              { 
1718   5                //level_to_average = level_to_average >> 2;
1719   5                if (belong_to_interval_lcro(level_to_average, 0, diff[0])) {
1720   6                    lumins_level_logic_prepared[0] = lumins_level_peace;
1721   6                    lumins_level_logic_prepared[1] = lumins_level_peace;
1722   6                    lumins_level_logic_prepared[2] = lumins_level_peace;
1723   6                } else if (belong_to_interval_lcro(level_to_average, diff[0], diff[1])) {
1724   6                    lumins_level_logic_prepared[0] = 3;
1725   6                    lumins_level_logic_prepared[1] = 3;
1726   6                    lumins_level_logic_prepared[2] = 3;
1727   6                } else if (belong_to_interval_lcro(level_to_average, diff[1], diff[2])) {
1728   6                    lumins_level_logic_prepared[0] = 4;
1729   6                    lumins_level_logic_prepared[1] = 4;
1730   6                    lumins_level_logic_prepared[2] = 4;
1731   6                } else if (belong_to_interval_lcro(level_to_average, diff[2], diff[3])) {
1732   6                    lumins_level_logic_prepared[0] = 5;
1733   6                    lumins_level_logic_prepared[1] = 5;
1734   6                    lumins_level_logic_prepared[2] = 5;
1735   6                } else if (belong_to_interval_lcro(level_to_average, diff[3], diff[4])) {
1736   6                    lumins_level_logic_prepared[0] = 6;
1737   6                    lumins_level_logic_prepared[1] = 6;
1738   6                    lumins_level_logic_prepared[2] = 6;
1739   6                } else if (belong_to_interval_lcro(level_to_average, diff[4], diff[5])) {
1740   6                    lumins_level_logic_prepared[0] = 7;
1741   6                    lumins_level_logic_prepared[1] = 7;
1742   6                    lumins_level_logic_prepared[2] = 7;
1743   6                } else if (belong_to_interval_lcro(level_to_average, diff[5], diff[6])) {
1744   6                    lumins_level_logic_prepared[0] = 8;
1745   6                    lumins_level_logic_prepared[1] = 8;
1746   6                    lumins_level_logic_prepared[2] = 8;
1747   6                } else if (belong_to_interval_lcro(level_to_average, diff[6], diff[7])) {
1748   6                    lumins_level_logic_prepared[0] = 9;
1749   6                    lumins_level_logic_prepared[1] = 9;
1750   6                    lumins_level_logic_prepared[2] = 9;
1751   6                } else if (belong_to_interval_lc(level_to_average, diff[7])) {
1752   6                    lumins_level_logic_prepared[0] = lumins_level_max;
1753   6                    lumins_level_logic_prepared[1] = lumins_level_max;
1754   6                    lumins_level_logic_prepared[2] = lumins_level_max;
1755   6                }
1756   5              }
1757   4            }
1758   3            // }
1759   3          } // end-of-first-if
1760   2        // }
1761   2          if(display_mode_logic == in_wave)
1762   2          {
1763   3            lumins_level_logic_prepared[1] = lumins_level_logic_prepared_for_deviation[0];
1764   3            lumins_level_logic_prepared[2] = lumins_level_logic_prepared_for_deviation[1];
1765   3          }
1766   2          if(display_mode_logic == slow_fade)
1767   2          {
1768   3            u8 i;
1769   3            for(i = 0; i < 3; i++){
1770   4              if(!lumins_level_logic_prepared_for_deviation[i])
1771   4                lumins_level_logic_prepared[i] = lumins_level_logic_prepared_for_deviation[i] - 1;    
1772   4            }
1773   3          }
1774   2          if(display_mode_logic == pulsing)
1775   2          {
1776   3            u8 i;
1777   3            for(i = 0; i < 3; i++)
1778   3              lumins_level_logic_prepared[i] = (dim_in_out_flag == HALF) ? lumins_level_logic_prepared[i] >> 1 : ((l
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 30  

             -umins_level_logic_prepared[i] >> 1) + 5);
1779   3          }
1780   2          
1781   2          if(display_mode_logic == bi_directional_storbing)
1782   2          {
1783   3            if(current_interval == 0)
1784   3            {
1785   4              lumins_level_logic_prepared[0] = lumins_level_logic_prepared[0];
1786   4              lumins_level_logic_prepared[1] = lumins_level_logic_prepared[1];
1787   4              lumins_level_logic_prepared[2] = lumins_level_logic_prepared[2];
1788   4            }
1789   3            if(current_interval == 8)
1790   3            {
1791   4              lumins_level_logic_prepared[0] = lumins_level_logic_prepared[0] >> 1;
1792   4              lumins_level_logic_prepared[1] = lumins_level_logic_prepared[1] >> 1;
1793   4              lumins_level_logic_prepared[2] = lumins_level_logic_prepared[2] >> 1;
1794   4            }
1795   3            if(current_interval == 16)
1796   3            {
1797   4              lumins_level_logic_prepared[0] = lumins_level_logic_prepared[0] >> 2;
1798   4              lumins_level_logic_prepared[1] = lumins_level_logic_prepared[1] >> 2;
1799   4              lumins_level_logic_prepared[2] = lumins_level_logic_prepared[2] >> 2;
1800   4            }
1801   3          }
1802   2        }
1803   1      }
1804          
1805          static void
1806          sensor_driver_init() {
1807   1        
1808   1        u8 buffer_size = AVG_BUFFER_SIZE;
1809   1        u8 i;
1810   1        sensor_initializing = YES;
1811   1        current_interval = 0;
1812   1        // quick output params response
1813   1        // if(!P30)
1814   1        // {
1815   1        //  cycle_output[0] = ON;
1816   1        //  cycle_output[1] = ON;
1817   1        //  cycle_output[2] = ON;
1818   1        // }
1819   1        // else
1820   1        // {
1821   1        //  cycle_output[0] = ON;
1822   1        //  cycle_output[1] = OFF;
1823   1        //  cycle_output[2] = OFF;
1824   1        // } 
1825   1        // lumins_level_logic_prepared[0] = lumins_level_peace;
1826   1        // lumins_level_logic_prepared[1] = lumins_level_peace;
1827   1        // lumins_level_logic_prepared[2] = lumins_level_peace;
1828   1        max_avg_index = 0;
1829   1        // Reset buffer
1830   1        for (i = buffer_size; i; )
1831   1          avg_buffer[--i] = BASE_AVG;
1832   1        max_sum = BASE_AVG << AVG_BUFFER_SIZE_BIT;
1833   1        max_avg = BASE_AVG;
1834   1        period_max_index = 0;
1835   1        buffer_size = PERIOD_MAX_SIZE;
1836   1        for (i = buffer_size; i; )
1837   1          period_max_buffer[--i] = 0;
1838   1        // adc_enable();
1839   1      }
C51 COMPILER V9.52.0.0   DISPLAY                                                           10/11/2015 15:46:03 PAGE 31  

1840          
1841          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5252    ----
   CONSTANT SIZE    =    656    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =     45      49
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
